This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/
  workflows/
    rust.yml
benches/
  kzg_benches.rs
src/
  test_formats/
    blob_to_kzg_commitment_test.rs
    compute_blob_kzg_proof.rs
    compute_kzg_proof.rs
    mod.rs
    verify_blob_kzg_proof_batch.rs
    verify_blob_kzg_proof.rs
    verify_kzg_proof.rs
  consts.rs
  kzg.rs
  lib.rs
  trusted_setup.rs
  utils.rs
tests/
  blob_to_kzg_commitment/
    small/
      blob_to_kzg_commitment_case_invalid_blob_59d64ff6b4648fad/
        data.yaml
      blob_to_kzg_commitment_case_invalid_blob_635fb2de5b0dc429/
        data.yaml
      blob_to_kzg_commitment_case_invalid_blob_a3b9ff28507767f8/
        data.yaml
      blob_to_kzg_commitment_case_invalid_blob_d3afbd98123a3434/
        data.yaml
      blob_to_kzg_commitment_case_valid_blob_0951cfd9ab47a8d3/
        data.yaml
      blob_to_kzg_commitment_case_valid_blob_19b3f3f8c98ea31e/
        data.yaml
      blob_to_kzg_commitment_case_valid_blob_84d8089232bc23a8/
        data.yaml
      blob_to_kzg_commitment_case_valid_blob_c40b9b515df8721b/
        data.yaml
      blob_to_kzg_commitment_case_valid_blob_cdb3e6d49eb12307/
        data.yaml
      blob_to_kzg_commitment_case_valid_blob_fb324bc819407148/
        data.yaml
  compute_blob_kzg_proof/
    small/
      compute_blob_kzg_proof_case_invalid_blob_59d64ff6b4648fad/
        data.yaml
      compute_blob_kzg_proof_case_invalid_blob_635fb2de5b0dc429/
        data.yaml
      compute_blob_kzg_proof_case_invalid_blob_a3b9ff28507767f8/
        data.yaml
      compute_blob_kzg_proof_case_invalid_blob_d3afbd98123a3434/
        data.yaml
      compute_blob_kzg_proof_case_invalid_commitment_1a68c47b68148e78/
        data.yaml
      compute_blob_kzg_proof_case_invalid_commitment_24b932fb4dec5b2d/
        data.yaml
      compute_blob_kzg_proof_case_invalid_commitment_3a6eb616efae0627/
        data.yaml
      compute_blob_kzg_proof_case_invalid_commitment_d070689c3e15444c/
        data.yaml
      compute_blob_kzg_proof_case_valid_blob_0951cfd9ab47a8d3/
        data.yaml
      compute_blob_kzg_proof_case_valid_blob_19b3f3f8c98ea31e/
        data.yaml
      compute_blob_kzg_proof_case_valid_blob_84d8089232bc23a8/
        data.yaml
      compute_blob_kzg_proof_case_valid_blob_c40b9b515df8721b/
        data.yaml
      compute_blob_kzg_proof_case_valid_blob_cdb3e6d49eb12307/
        data.yaml
      compute_blob_kzg_proof_case_valid_blob_fb324bc819407148/
        data.yaml
  compute_kzg_proof/
    small/
      compute_kzg_proof_case_invalid_blob_59d64ff6b4648fad/
        data.yaml
      compute_kzg_proof_case_invalid_blob_635fb2de5b0dc429/
        data.yaml
      compute_kzg_proof_case_invalid_blob_a3b9ff28507767f8/
        data.yaml
      compute_kzg_proof_case_invalid_blob_d3afbd98123a3434/
        data.yaml
      compute_kzg_proof_case_invalid_z_03265c1605637b1f/
        data.yaml
      compute_kzg_proof_case_invalid_z_881cc19564a97501/
        data.yaml
      compute_kzg_proof_case_invalid_z_8e021fdb13259641/
        data.yaml
      compute_kzg_proof_case_invalid_z_9683af102559ddf0/
        data.yaml
      compute_kzg_proof_case_invalid_z_9df8c89b61183887/
        data.yaml
      compute_kzg_proof_case_invalid_z_b30d81e81c1262b6/
        data.yaml
      compute_kzg_proof_case_valid_blob_02e696ada7d4631d/
        data.yaml
      compute_kzg_proof_case_valid_blob_08f9e2f1cb3d39db/
        data.yaml
      compute_kzg_proof_case_valid_blob_0cf79b17cb5f4ea2/
        data.yaml
      compute_kzg_proof_case_valid_blob_1ce8e4f69d5df899/
        data.yaml
      compute_kzg_proof_case_valid_blob_26b753dec0560daa/
        data.yaml
      compute_kzg_proof_case_valid_blob_31ebd010e6098750/
        data.yaml
      compute_kzg_proof_case_valid_blob_3208425794224c3f/
        data.yaml
      compute_kzg_proof_case_valid_blob_36817bfd67de97a8/
        data.yaml
      compute_kzg_proof_case_valid_blob_392169c16a2e5ef6/
        data.yaml
      compute_kzg_proof_case_valid_blob_3ac8dc31e9aa6a70/
        data.yaml
      compute_kzg_proof_case_valid_blob_3c1e8b38219e3e12/
        data.yaml
      compute_kzg_proof_case_valid_blob_3c87ec986c2656c2/
        data.yaml
      compute_kzg_proof_case_valid_blob_3cd183d0bab85fb7/
        data.yaml
      compute_kzg_proof_case_valid_blob_420f2a187ce77035/
        data.yaml
      compute_kzg_proof_case_valid_blob_444b73ff54a19b44/
        data.yaml
      compute_kzg_proof_case_valid_blob_53a9bdf4f75196da/
        data.yaml
      compute_kzg_proof_case_valid_blob_7db4f140a955dd1a/
        data.yaml
      compute_kzg_proof_case_valid_blob_83e53423a2dd93fe/
        data.yaml
      compute_kzg_proof_case_valid_blob_9b24f8997145435c/
        data.yaml
      compute_kzg_proof_case_valid_blob_9b754afb690c47e1/
        data.yaml
      compute_kzg_proof_case_valid_blob_af669445747d2585/
        data.yaml
      compute_kzg_proof_case_valid_blob_af8b75f664ed7d43/
        data.yaml
      compute_kzg_proof_case_valid_blob_b6cb6698327d9835/
        data.yaml
      compute_kzg_proof_case_valid_blob_b6ec3736f9ff2c62/
        data.yaml
      compute_kzg_proof_case_valid_blob_becf2e1641bbd4e6/
        data.yaml
      compute_kzg_proof_case_valid_blob_c3d4322ec17fe7cd/
        data.yaml
      compute_kzg_proof_case_valid_blob_c5e1490d672d026d/
        data.yaml
      compute_kzg_proof_case_valid_blob_cae5d3491190b777/
        data.yaml
      compute_kzg_proof_case_valid_blob_d0992bc0387790a4/
        data.yaml
      compute_kzg_proof_case_valid_blob_d736268229bd87ec/
        data.yaml
      compute_kzg_proof_case_valid_blob_e68d7111a2364a49/
        data.yaml
      compute_kzg_proof_case_valid_blob_ed6b180ec759bcf6/
        data.yaml
      compute_kzg_proof_case_valid_blob_f0ed3dc11cdeb130/
        data.yaml
      compute_kzg_proof_case_valid_blob_f47eb9fc139f6bfd/
        data.yaml
      compute_kzg_proof_case_valid_blob_f7f44e1e864aa967/
        data.yaml
      compute_kzg_proof_case_valid_blob_ffa6e97b97146517/
        data.yaml
  verify_blob_kzg_proof/
    small/
      verify_blob_kzg_proof_case_correct_proof_0951cfd9ab47a8d3/
        data.yaml
      verify_blob_kzg_proof_case_correct_proof_19b3f3f8c98ea31e/
        data.yaml
      verify_blob_kzg_proof_case_correct_proof_84d8089232bc23a8/
        data.yaml
      verify_blob_kzg_proof_case_correct_proof_c40b9b515df8721b/
        data.yaml
      verify_blob_kzg_proof_case_correct_proof_cdb3e6d49eb12307/
        data.yaml
      verify_blob_kzg_proof_case_correct_proof_fb324bc819407148/
        data.yaml
      verify_blob_kzg_proof_case_incorrect_proof_0951cfd9ab47a8d3/
        data.yaml
      verify_blob_kzg_proof_case_incorrect_proof_19b3f3f8c98ea31e/
        data.yaml
      verify_blob_kzg_proof_case_incorrect_proof_84d8089232bc23a8/
        data.yaml
      verify_blob_kzg_proof_case_incorrect_proof_c40b9b515df8721b/
        data.yaml
      verify_blob_kzg_proof_case_incorrect_proof_cdb3e6d49eb12307/
        data.yaml
      verify_blob_kzg_proof_case_incorrect_proof_fb324bc819407148/
        data.yaml
      verify_blob_kzg_proof_case_invalid_blob_59d64ff6b4648fad/
        data.yaml
      verify_blob_kzg_proof_case_invalid_blob_635fb2de5b0dc429/
        data.yaml
      verify_blob_kzg_proof_case_invalid_blob_a3b9ff28507767f8/
        data.yaml
      verify_blob_kzg_proof_case_invalid_blob_d3afbd98123a3434/
        data.yaml
      verify_blob_kzg_proof_case_invalid_commitment_1a68c47b68148e78/
        data.yaml
      verify_blob_kzg_proof_case_invalid_commitment_24b932fb4dec5b2d/
        data.yaml
      verify_blob_kzg_proof_case_invalid_commitment_3a6eb616efae0627/
        data.yaml
      verify_blob_kzg_proof_case_invalid_commitment_d070689c3e15444c/
        data.yaml
      verify_blob_kzg_proof_case_invalid_proof_1a68c47b68148e78/
        data.yaml
      verify_blob_kzg_proof_case_invalid_proof_24b932fb4dec5b2d/
        data.yaml
      verify_blob_kzg_proof_case_invalid_proof_3a6eb616efae0627/
        data.yaml
      verify_blob_kzg_proof_case_invalid_proof_d070689c3e15444c/
        data.yaml
  verify_blob_kzg_proof_batch/
    small/
      verify_blob_kzg_proof_batch_case_0951cfd9ab47a8d3/
        data.yaml
      verify_blob_kzg_proof_batch_case_5bebe168d7c33c6a/
        data.yaml
      verify_blob_kzg_proof_batch_case_879dfd1fc2116abd/
        data.yaml
      verify_blob_kzg_proof_batch_case_a271b78b8e869d69/
        data.yaml
      verify_blob_kzg_proof_batch_case_af635e3f6928eb5d/
        data.yaml
      verify_blob_kzg_proof_batch_case_blob_length_different/
        data.yaml
      verify_blob_kzg_proof_batch_case_commitment_length_different/
        data.yaml
      verify_blob_kzg_proof_batch_case_eb466183cba29678/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_blob_59d64ff6b4648fad/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_blob_635fb2de5b0dc429/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_blob_a3b9ff28507767f8/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_blob_d3afbd98123a3434/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_commitment_1a68c47b68148e78/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_commitment_24b932fb4dec5b2d/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_commitment_3a6eb616efae0627/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_commitment_d070689c3e15444c/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_proof/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_proof_1a68c47b68148e78/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_proof_24b932fb4dec5b2d/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_proof_3a6eb616efae0627/
        data.yaml
      verify_blob_kzg_proof_batch_case_invalid_proof_d070689c3e15444c/
        data.yaml
      verify_blob_kzg_proof_batch_case_proof_length_different/
        data.yaml
  verify_kzg_proof/
    small/
      verify_kzg_proof_case_correct_proof_02e696ada7d4631d/
        data.yaml
      verify_kzg_proof_case_correct_proof_08f9e2f1cb3d39db/
        data.yaml
      verify_kzg_proof_case_correct_proof_0cf79b17cb5f4ea2/
        data.yaml
      verify_kzg_proof_case_correct_proof_1ce8e4f69d5df899/
        data.yaml
      verify_kzg_proof_case_correct_proof_26b753dec0560daa/
        data.yaml
      verify_kzg_proof_case_correct_proof_31ebd010e6098750/
        data.yaml
      verify_kzg_proof_case_correct_proof_3208425794224c3f/
        data.yaml
      verify_kzg_proof_case_correct_proof_36817bfd67de97a8/
        data.yaml
      verify_kzg_proof_case_correct_proof_392169c16a2e5ef6/
        data.yaml
      verify_kzg_proof_case_correct_proof_3ac8dc31e9aa6a70/
        data.yaml
      verify_kzg_proof_case_correct_proof_3c1e8b38219e3e12/
        data.yaml
      verify_kzg_proof_case_correct_proof_3c87ec986c2656c2/
        data.yaml
      verify_kzg_proof_case_correct_proof_3cd183d0bab85fb7/
        data.yaml
      verify_kzg_proof_case_correct_proof_420f2a187ce77035/
        data.yaml
      verify_kzg_proof_case_correct_proof_444b73ff54a19b44/
        data.yaml
      verify_kzg_proof_case_correct_proof_53a9bdf4f75196da/
        data.yaml
      verify_kzg_proof_case_correct_proof_7db4f140a955dd1a/
        data.yaml
      verify_kzg_proof_case_correct_proof_83e53423a2dd93fe/
        data.yaml
      verify_kzg_proof_case_correct_proof_9b24f8997145435c/
        data.yaml
      verify_kzg_proof_case_correct_proof_9b754afb690c47e1/
        data.yaml
      verify_kzg_proof_case_correct_proof_af669445747d2585/
        data.yaml
      verify_kzg_proof_case_correct_proof_af8b75f664ed7d43/
        data.yaml
      verify_kzg_proof_case_correct_proof_b6cb6698327d9835/
        data.yaml
      verify_kzg_proof_case_correct_proof_b6ec3736f9ff2c62/
        data.yaml
      verify_kzg_proof_case_correct_proof_becf2e1641bbd4e6/
        data.yaml
      verify_kzg_proof_case_correct_proof_c3d4322ec17fe7cd/
        data.yaml
      verify_kzg_proof_case_correct_proof_c5e1490d672d026d/
        data.yaml
      verify_kzg_proof_case_correct_proof_cae5d3491190b777/
        data.yaml
      verify_kzg_proof_case_correct_proof_d0992bc0387790a4/
        data.yaml
      verify_kzg_proof_case_correct_proof_d736268229bd87ec/
        data.yaml
      verify_kzg_proof_case_correct_proof_e68d7111a2364a49/
        data.yaml
      verify_kzg_proof_case_correct_proof_ed6b180ec759bcf6/
        data.yaml
      verify_kzg_proof_case_correct_proof_f0ed3dc11cdeb130/
        data.yaml
      verify_kzg_proof_case_correct_proof_f47eb9fc139f6bfd/
        data.yaml
      verify_kzg_proof_case_correct_proof_f7f44e1e864aa967/
        data.yaml
      verify_kzg_proof_case_correct_proof_ffa6e97b97146517/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_02e696ada7d4631d/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_08f9e2f1cb3d39db/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_0cf79b17cb5f4ea2/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_1ce8e4f69d5df899/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_26b753dec0560daa/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_31ebd010e6098750/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_3208425794224c3f/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_36817bfd67de97a8/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_392169c16a2e5ef6/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_3ac8dc31e9aa6a70/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_3c1e8b38219e3e12/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_3c87ec986c2656c2/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_3cd183d0bab85fb7/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_420f2a187ce77035/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_444b73ff54a19b44/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_53a9bdf4f75196da/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_7db4f140a955dd1a/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_83e53423a2dd93fe/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_9b24f8997145435c/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_9b754afb690c47e1/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_af669445747d2585/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_af8b75f664ed7d43/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_b6cb6698327d9835/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_b6ec3736f9ff2c62/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_becf2e1641bbd4e6/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_c3d4322ec17fe7cd/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_c5e1490d672d026d/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_cae5d3491190b777/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_d0992bc0387790a4/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_d736268229bd87ec/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_e68d7111a2364a49/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_ed6b180ec759bcf6/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_f0ed3dc11cdeb130/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_f47eb9fc139f6bfd/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_f7f44e1e864aa967/
        data.yaml
      verify_kzg_proof_case_incorrect_proof_ffa6e97b97146517/
        data.yaml
      verify_kzg_proof_case_invalid_commitment_1b44e341d56c757d/
        data.yaml
      verify_kzg_proof_case_invalid_commitment_32afa9561a4b3b91/
        data.yaml
      verify_kzg_proof_case_invalid_commitment_3e55802a5ed3c757/
        data.yaml
      verify_kzg_proof_case_invalid_commitment_e9d3e9ec16fbc15f/
        data.yaml
      verify_kzg_proof_case_invalid_proof_1b44e341d56c757d/
        data.yaml
      verify_kzg_proof_case_invalid_proof_32afa9561a4b3b91/
        data.yaml
      verify_kzg_proof_case_invalid_proof_3e55802a5ed3c757/
        data.yaml
      verify_kzg_proof_case_invalid_proof_e9d3e9ec16fbc15f/
        data.yaml
      verify_kzg_proof_case_invalid_y_35d08d612aad2197/
        data.yaml
      verify_kzg_proof_case_invalid_y_4aa6def8c35c9097/
        data.yaml
      verify_kzg_proof_case_invalid_y_4e51cef08a61606f/
        data.yaml
      verify_kzg_proof_case_invalid_y_64b9ff2b8f7dddee/
        data.yaml
      verify_kzg_proof_case_invalid_y_b358a2e763727b70/
        data.yaml
      verify_kzg_proof_case_invalid_y_eb0601fec84cc5e9/
        data.yaml
      verify_kzg_proof_case_invalid_z_35d08d612aad2197/
        data.yaml
      verify_kzg_proof_case_invalid_z_4aa6def8c35c9097/
        data.yaml
      verify_kzg_proof_case_invalid_z_4e51cef08a61606f/
        data.yaml
      verify_kzg_proof_case_invalid_z_64b9ff2b8f7dddee/
        data.yaml
      verify_kzg_proof_case_invalid_z_b358a2e763727b70/
        data.yaml
      verify_kzg_proof_case_invalid_z_eb0601fec84cc5e9/
        data.yaml
.gitignore
Cargo.toml
LICENSE
README.md
testing_trusted_setups.json
trusted_setup.txt

================================================================
Files
================================================================

================
File: .github/workflows/rust.yml
================
name: Rust
on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  tests:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os:
          - ubuntu-latest
          - windows-latest
          - macos-latest
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive
      - name: Get latest version of stable rust
        run: rustup update stable
      - name: Build and Test
        run: cargo test --all --release --tests
      - name: Benchmark
        run: cargo bench

================
File: benches/kzg_benches.rs
================
use criterion::{criterion_group, criterion_main, BatchSize, BenchmarkId, Criterion, Throughput};
use kzg_rust::*;
use rand::{rngs::ThreadRng, Rng};

const TRUSTED_SETUP: &str = "trusted_setup.txt";

fn generate_random_field_element(rng: &mut ThreadRng) -> Bytes32 {
    let mut arr = [0u8; BYTES_PER_FIELD_ELEMENT];
    rng.fill(&mut arr[..]);
    arr[0] = 0;
    arr.into()
}

fn generate_random_blob(rng: &mut ThreadRng) -> Blob {
    let mut arr = [0u8; BYTES_PER_BLOB];
    rng.fill(&mut arr[..]);
    // Ensure that the blob is canonical by ensuring that
    // each field element contained in the blob is < BLS_MODULUS
    for i in 0..FIELD_ELEMENTS_PER_BLOB {
        arr[i * BYTES_PER_FIELD_ELEMENT] = 0;
    }
    arr.into()
}

pub fn criterion_benchmark(c: &mut Criterion) {
    let max_count: usize = 64;
    let mut rng = rand::thread_rng();
    let kzg_settings = Kzg::load_trusted_setup_file(TRUSTED_SETUP).unwrap();

    let blobs: Vec<Blob> = (0..max_count)
        .map(|_| generate_random_blob(&mut rng))
        .collect();
    let commitments: Vec<KzgCommitment> = blobs
        .iter()
        .map(|blob| Kzg::blob_to_kzg_commitment(blob, &kzg_settings).unwrap())
        .collect();
    let proofs: Vec<KzgProof> = blobs
        .iter()
        .zip(commitments.iter())
        .map(|(blob, commitment)| Kzg::compute_blob_kzg_proof(blob, commitment, &kzg_settings).unwrap())
        .collect();
    let fields: Vec<Bytes32> = (0..max_count)
        .map(|_| generate_random_field_element(&mut rng))
        .collect();

    c.bench_function("blob_to_kzg_commitment", |b| {
        b.iter(|| Kzg::blob_to_kzg_commitment(blobs.first().unwrap(), &kzg_settings))
    });

    c.bench_function("compute_kzg_proof", |b| {
        b.iter(|| {
            Kzg::compute_kzg_proof(
                blobs.first().unwrap(),
                fields.first().unwrap(),
                &kzg_settings,
            )
        })
    });

    c.bench_function("compute_blob_kzg_proof", |b| {
        b.iter(|| {
            Kzg::compute_blob_kzg_proof(
                blobs.first().unwrap(),
                commitments.first().unwrap(),
                &kzg_settings,
            )
        })
    });

    c.bench_function("verify_kzg_proof", |b| {
        b.iter(|| {
            Kzg::verify_kzg_proof(
                commitments.first().unwrap(),
                fields.first().unwrap(),
                fields.first().unwrap(),
                proofs.first().unwrap(),
                &kzg_settings,
            )
        })
    });

    c.bench_function("verify_blob_kzg_proof", |b| {
        b.iter(|| {
            Kzg::verify_blob_kzg_proof(
                blobs.first().unwrap(),
                commitments.first().unwrap(),
                proofs.first().unwrap(),
                &kzg_settings,
            )
        })
    });

    let mut group = c.benchmark_group("verify_blob_kzg_proof_batch");
    for count in [1, 2, 4, 8, 16, 32, 64] {
        group.throughput(Throughput::Elements(count as u64));
        group.bench_with_input(BenchmarkId::from_parameter(count), &count, |b, &count| {
            b.iter_batched_ref(
                || {
                    let blobs_subset = blobs.clone().into_iter().take(count).collect::<Vec<Blob>>();
                    let commitments_subset = commitments
                        .clone()
                        .into_iter()
                        .take(count)
                        .collect::<Vec<KzgCommitment>>();
                    let proofs_subset = proofs
                        .clone()
                        .into_iter()
                        .take(count)
                        .collect::<Vec<KzgProof>>();

                    (blobs_subset, commitments_subset, proofs_subset)
                },
                |(blobs_subset, commitments_subset, proofs_subset)| {
                    Kzg::verify_blob_kzg_proof_batch(
                        &blobs_subset,
                        &commitments_subset,
                        &proofs_subset,
                        &kzg_settings,
                    )
                    .unwrap();
                },
                BatchSize::LargeInput,
            );
        });
    }
    group.finish();
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);

================
File: src/test_formats/blob_to_kzg_commitment_test.rs
================
#![allow(dead_code)]

use crate::{Bytes48, Error, Blob};
use serde::Deserialize;

#[derive(Deserialize)]
pub struct Input<'a> {
    blob: &'a str,
}

impl Input<'_> {
    pub fn get_blob(&self) -> Result<Blob, Error> {
        Blob::from_hex(self.blob)
    }
}

#[derive(Deserialize)]
pub struct Test<'a> {
    #[serde(borrow)]
    pub input: Input<'a>,
    #[serde(borrow)]
    output: Option<&'a str>,
}

impl Test<'_> {
    pub fn get_output(&self) -> Option<Bytes48> {
        self.output.map(|s| Bytes48::from_hex(s).unwrap())
    }
}

================
File: src/test_formats/compute_blob_kzg_proof.rs
================
#![allow(dead_code)]

use crate::{Blob, Bytes48, Error};
use serde::Deserialize;

#[derive(Deserialize)]
pub struct Input<'a> {
    blob: &'a str,
    commitment: &'a str,
}

impl Input<'_> {
    pub fn get_blob(&self) -> Result<Blob, Error> {
        Blob::from_hex(self.blob)
    }

    pub fn get_commitment(&self) -> Result<Bytes48, Error> {
        Bytes48::from_hex(self.commitment)
    }
}

#[derive(Deserialize)]
pub struct Test<'a> {
    #[serde(borrow)]
    pub input: Input<'a>,
    #[serde(borrow)]
    output: Option<&'a str>,
}

impl Test<'_> {
    pub fn get_output(&self) -> Option<Bytes48> {
        self.output.map(|s| Bytes48::from_hex(s).unwrap())
    }
}

================
File: src/test_formats/compute_kzg_proof.rs
================
#![allow(dead_code)]
use crate::{Blob, Bytes32, Bytes48, Error};
use serde::Deserialize;

#[derive(Deserialize)]
pub struct Input<'a> {
    blob: &'a str,
    z: &'a str,
}

impl Input<'_> {
    pub fn get_blob(&self) -> Result<Blob, Error> {
        Blob::from_hex(self.blob)
    }

    pub fn get_z(&self) -> Result<Bytes32, Error> {
        Bytes32::from_hex(self.z)
    }
}

#[derive(Deserialize)]
pub struct Test<'a> {
    #[serde(borrow)]
    pub input: Input<'a>,
    #[serde(borrow)]
    output: Option<(&'a str, &'a str)>,
}

impl Test<'_> {
    pub fn get_output(&self) -> Option<(Bytes48, Bytes32)> {
        self.output.map(|(proof, y)| {
            (
                Bytes48::from_hex(proof).unwrap(),
                Bytes32::from_hex(y).unwrap(),
            )
        })
    }
}

================
File: src/test_formats/mod.rs
================
pub mod blob_to_kzg_commitment_test;
pub mod compute_blob_kzg_proof;
pub mod compute_kzg_proof;
pub mod verify_blob_kzg_proof;
pub mod verify_blob_kzg_proof_batch;
pub mod verify_kzg_proof;

================
File: src/test_formats/verify_blob_kzg_proof_batch.rs
================
#![allow(dead_code)]

use crate::{Blob, Error, KzgCommitment, KzgProof};
use serde::Deserialize;

#[derive(Deserialize)]
pub struct Input {
    blobs: Vec<String>,
    commitments: Vec<String>,
    proofs: Vec<String>,
}

impl Input {
    pub fn get_blobs(&self) -> Result<Vec<Blob>, Error> {
        let mut v: Vec<Blob> = Vec::new();
        for blob in &self.blobs {
            v.push(Blob::from_hex(blob)?);
        }
        Ok(v)
    }

    pub fn get_commitments(&self) -> Result<Vec<KzgCommitment>, Error> {
        self.commitments
            .iter()
            .map(|s| KzgCommitment::from_hex(s))
            .collect::<Result<Vec<KzgCommitment>, Error>>()
    }

    pub fn get_proofs(&self) -> Result<Vec<KzgProof>, Error> {
        self.proofs
            .iter()
            .map(|s| KzgProof::from_hex(s))
            .collect::<Result<Vec<KzgProof>, Error>>()
    }
}

#[derive(Deserialize)]
pub struct Test {
    pub input: Input,
    output: Option<bool>,
}

impl Test {
    pub fn get_output(&self) -> Option<bool> {
        self.output
    }
}

================
File: src/test_formats/verify_blob_kzg_proof.rs
================
#![allow(dead_code)]

use crate::{Blob, Bytes48, Error};

use serde::Deserialize;

#[derive(Deserialize)]
pub struct Input<'a> {
    blob: &'a str,
    commitment: &'a str,
    proof: &'a str,
}

impl Input<'_> {
    pub fn get_blob(&self) -> Result<Blob, Error> {
        Blob::from_hex(self.blob)
    }

    pub fn get_commitment(&self) -> Result<Bytes48, Error> {
        Bytes48::from_hex(self.commitment)
    }

    pub fn get_proof(&self) -> Result<Bytes48, Error> {
        Bytes48::from_hex(self.proof)
    }
}

#[derive(Deserialize)]
pub struct Test<'a> {
    #[serde(borrow)]
    pub input: Input<'a>,
    output: Option<bool>,
}

impl Test<'_> {
    pub fn get_output(&self) -> Option<bool> {
        self.output
    }
}

================
File: src/test_formats/verify_kzg_proof.rs
================
#![allow(dead_code)]

use crate::{Bytes32, Bytes48, Error};
use serde::Deserialize;

#[derive(Deserialize)]
pub struct Input<'a> {
    commitment: &'a str,
    z: &'a str,
    y: &'a str,
    proof: &'a str,
}

impl Input<'_> {
    pub fn get_commitment(&self) -> Result<Bytes48, Error> {
        Bytes48::from_hex(self.commitment)
    }

    pub fn get_z(&self) -> Result<Bytes32, Error> {
        Bytes32::from_hex(self.z)
    }

    pub fn get_y(&self) -> Result<Bytes32, Error> {
        Bytes32::from_hex(self.y)
    }

    pub fn get_proof(&self) -> Result<Bytes48, Error> {
        Bytes48::from_hex(self.proof)
    }
}

#[derive(Deserialize)]
pub struct Test<'a> {
    #[serde(borrow)]
    pub input: Input<'a>,
    output: Option<bool>,
}

impl Test<'_> {
    pub fn get_output(&self) -> Option<bool> {
        self.output
    }
}

================
File: src/consts.rs
================
use blst::*;
use blst::{blst_fr as fr_t, blst_p1 as g1_t, blst_p2 as g2_t};

/// The number of bytes in a BLS scalar field element.
pub const BYTES_PER_FIELD_ELEMENT: usize = 32;

/// The number of bytes in a KZG commitment.
pub const BYTES_PER_COMMITMENT: usize = 48;

/// The number of bytes in a KZG proof.
pub const BYTES_PER_PROOF: usize = 48;

pub const FIELD_ELEMENTS_PER_BLOB: usize = 4096;

/// Number of bytes in a blob.
pub const BYTES_PER_BLOB: usize = FIELD_ELEMENTS_PER_BLOB * BYTES_PER_FIELD_ELEMENT;

/// Input size to the Fiat-Shamir challenge computation.
pub const CHALLENGE_INPUT_SIZE: usize = DOMAIN_STR_LENGTH + 16 + BYTES_PER_BLOB + BYTES_PER_COMMITMENT;

/// Domain seperator for the Fiat-Shamir protocol.
pub const FIAT_SHAMIR_PROTOCOL_DOMAIN: &str = "FSBLOBVERIFY_V1_";

/// Domain sepearator for a random challenge.
pub const RANDOM_CHALLENGE_KZG_BATCH_DOMAIN: &str = "RCKZGBATCH___V1_";

/// Length of above domain strings.
pub const DOMAIN_STR_LENGTH: usize = 16;

/// The number of bytes in a g1 point.
pub const BYTES_PER_G1: usize = 48;

/// The number of bytes in a g2 point.
pub const BYTES_PER_G2: usize = 96;

/// The number of g2 points in a trusted setup.
pub const TRUSTED_SETUP_NUM_G2_POINTS: usize = 65;

/// Deserialized form of the G1 identity/infinity point
pub const G1_IDENTITY: g1_t = g1_t {
    x: blst::blst_fp { l: [0; 6] },
    y: blst::blst_fp { l: [0; 6] },
    z: blst::blst_fp { l: [0; 6] },
};

/// The G1 generator.
pub const G1_GENERATOR: g1_t = g1_t {
    x: blst::blst_fp {
        l: [
            0x5cb38790fd530c16,
            0x7817fc679976fff5,
            0x154f95c7143ba1c1,
            0xf0ae6acdf3d0e747,
            0xedce6ecc21dbf440,
            0x120177419e0bfb75,
        ],
    },
    y: blst::blst_fp {
        l: [
            0xbaac93d50ce72271,
            0x8c22631a7918fd8e,
            0xdd595f13570725ce,
            0x51ac582950405194,
            0x0e1c8c3fad0059c0,
            0x0bbc3efc5008a26a,
        ],
    },
    z: blst::blst_fp {
        l: [
            0x760900000002fffd,
            0xebf4000bc40c0002,
            0x5f48985753c758ba,
            0x77ce585370525745,
            0x5c071a97a256ec6d,
            0x15f65ec3fa80e493,
        ],
    },
};

/// The G2 generator.
pub const G2_GENERATOR: g2_t = g2_t {
    x: blst::blst_fp2 {
        fp: [
            blst_fp {
                l: [
                    0xf5f28fa202940a10,
                    0xb3f5fb2687b4961a,
                    0xa1a893b53e2ae580,
                    0x9894999d1a3caee9,
                    0x6f67b7631863366b,
                    0x058191924350bcd7,
                ],
            },
            blst_fp {
                l: [
                    0xa5a9c0759e23f606,
                    0xaaa0c59dbccd60c3,
                    0x3bb17e18e2867806,
                    0x1b1ab6cc8541b367,
                    0xc2b6ed0ef2158547,
                    0x11922a097360edf3,
                ],
            },
        ],
    },
    y: blst::blst_fp2 {
        fp: [
            blst_fp {
                l: [
                    0x4c730af860494c4a,
                    0x597cfa1f5e369c5a,
                    0xe7e6856caa0a635a,
                    0xbbefb5e96e0d495f,
                    0x07d3a975f0ef25a2,
                    0x0083fd8e7e80dae5,
                ],
            },
            blst_fp {
                l: [
                    0xadc0fc92df64b05d,
                    0x18aa270a2b1461dc,
                    0x86adac6a3be4eba0,
                    0x79495c4ec93da33a,
                    0xe7175850a43ccaed,
                    0x0b2bc2a163de1bf2,
                ],
            },
        ],
    },
    z: blst::blst_fp2 {
        fp: [
            blst_fp {
                l: [
                    0x760900000002fffd,
                    0xebf4000bc40c0002,
                    0x5f48985753c758ba,
                    0x77ce585370525745,
                    0x5c071a97a256ec6d,
                    0x15f65ec3fa80e493,
                ],
            },
            blst_fp {
                l: [
                    0x0000000000000000,
                    0x0000000000000000,
                    0x0000000000000000,
                    0x0000000000000000,
                    0x0000000000000000,
                    0x0000000000000000,
                ],
            },
        ],
    },
};

/// The first 32 roots of unity in the finite field `F_r`.
/// SCALE2_ROOT_OF_UNITY[i] is a 2^i'th root of unity.
///
/// For element `{A, B, C, D}`, the field element value is
/// `A + B * 2^64 + C * 2^128 + D * 2^192`. This format may be converted to
/// an `fr_t` type via the blst_fr_from_uint64() function.
///
/// The decimal values may be calculated with the following Python code:
/// ```python
/// MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513
/// PRIMITIVE_ROOT = 7
/// [pow(PRIMITIVE_ROOT, (MODULUS - 1) // (2**i), MODULUS) for i in range(32)]
/// ```
///
/// Note: Being a "primitive root" in this context means that `r^k != 1` for any
/// `k < q-1` where q is the modulus. So powers of r generate the field. This is
/// also known as being a "primitive element".
///
/// In the formula above, the restriction can be slightly relaxed to `r` being a non-square.
/// This is easy to check: We just require that r^((q-1)/2) == -1. Instead of
/// 5, we could use 7, 10, 13, 14, 15, 20... to create the 2^i'th roots of unity below.
/// Generally, there are a lot of primitive roots:
/// https://crypto.stanford.edu/pbc/notes/numbertheory/gen.html
pub const SCALE2_ROOT_OF_UNITY: [[u64; 4]; 32] = [
    [
        0x0000000000000001,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
    ],
    [
        0xffffffff00000000,
        0x53bda402fffe5bfe,
        0x3339d80809a1d805,
        0x73eda753299d7d48,
    ],
    [
        0x0001000000000000,
        0xec03000276030000,
        0x8d51ccce760304d0,
        0x0000000000000000,
    ],
    [
        0x7228fd3397743f7a,
        0xb38b21c28713b700,
        0x8c0625cd70d77ce2,
        0x345766f603fa66e7,
    ],
    [
        0x53ea61d87742bcce,
        0x17beb312f20b6f76,
        0xdd1c0af834cec32c,
        0x20b1ce9140267af9,
    ],
    [
        0x360c60997369df4e,
        0xbf6e88fb4c38fb8a,
        0xb4bcd40e22f55448,
        0x50e0903a157988ba,
    ],
    [
        0x8140d032f0a9ee53,
        0x2d967f4be2f95155,
        0x14a1e27164d8fdbd,
        0x45af6345ec055e4d,
    ],
    [
        0x5130c2c1660125be,
        0x98d0caac87f5713c,
        0xb7c68b4d7fdd60d0,
        0x6898111413588742,
    ],
    [
        0x4935bd2f817f694b,
        0x0a0865a899e8deff,
        0x6b368121ac0cf4ad,
        0x4f9b4098e2e9f12e,
    ],
    [
        0x4541b8ff2ee0434e,
        0xd697168a3a6000fe,
        0x39feec240d80689f,
        0x095166525526a654,
    ],
    [
        0x3c28d666a5c2d854,
        0xea437f9626fc085e,
        0x8f4de02c0f776af3,
        0x325db5c3debf77a1,
    ],
    [
        0x4a838b5d59cd79e5,
        0x55ea6811be9c622d,
        0x09f1ca610a08f166,
        0x6d031f1b5c49c834,
    ],
    [
        0xe206da11a5d36306,
        0x0ad1347b378fbf96,
        0xfc3e8acfe0f8245f,
        0x564c0a11a0f704f4,
    ],
    [
        0x6fdd00bfc78c8967,
        0x146b58bc434906ac,
        0x2ccddea2972e89ed,
        0x485d512737b1da3d,
    ],
    [
        0x034d2ff22a5ad9e1,
        0xae4622f6a9152435,
        0xdc86b01c0d477fa6,
        0x56624634b500a166,
    ],
    [
        0xfbd047e11279bb6e,
        0xc8d5f51db3f32699,
        0x483405417a0cbe39,
        0x3291357ee558b50d,
    ],
    [
        0xd7118f85cd96b8ad,
        0x67a665ae1fcadc91,
        0x88f39a78f1aeb578,
        0x2155379d12180caa,
    ],
    [
        0x08692405f3b70f10,
        0xcd7f2bd6d0711b7d,
        0x473a2eef772c33d6,
        0x224262332d8acbf4,
    ],
    [
        0x6f421a7d8ef674fb,
        0xbb97a3bf30ce40fd,
        0x652f717ae1c34bb0,
        0x2d3056a530794f01,
    ],
    [
        0x194e8c62ecb38d9d,
        0xad8e16e84419c750,
        0xdf625e80d0adef90,
        0x520e587a724a6955,
    ],
    [
        0xfece7e0e39898d4b,
        0x2f69e02d265e09d9,
        0xa57a6e07cb98de4a,
        0x03e1c54bcb947035,
    ],
    [
        0xcd3979122d3ea03a,
        0x46b3105f04db5844,
        0xc70d0874b0691d4e,
        0x47c8b5817018af4f,
    ],
    [
        0xc6e7a6ffb08e3363,
        0xe08fec7c86389bee,
        0xf2d38f10fbb8d1bb,
        0x0abe6a5e5abcaa32,
    ],
    [
        0x5616c57de0ec9eae,
        0xc631ffb2585a72db,
        0x5121af06a3b51e3c,
        0x73560252aa0655b2,
    ],
    [
        0x92cf4deb77bd779c,
        0x72cf6a8029b7d7bc,
        0x6e0bcd91ee762730,
        0x291cf6d68823e687,
    ],
    [
        0xce32ef844e11a51e,
        0xc0ba12bb3da64ca5,
        0x0454dc1edc61a1a3,
        0x019fe632fd328739,
    ],
    [
        0x531a11a0d2d75182,
        0x02c8118402867ddc,
        0x116168bffbedc11d,
        0x0a0a77a3b1980c0d,
    ],
    [
        0xe2d0a7869f0319ed,
        0xb94f1101b1d7a628,
        0xece8ea224f31d25d,
        0x23397a9300f8f98b,
    ],
    [
        0xd7b688830a4f2089,
        0x6558e9e3f6ac7b41,
        0x99e276b571905a7d,
        0x52dd465e2f094256,
    ],
    [
        0x474650359d8e211b,
        0x84d37b826214abc6,
        0x8da40c1ef2bb4598,
        0x0c83ea7744bf1bee,
    ],
    [
        0x694341f608c9dd56,
        0xed3a181fabb30adc,
        0x1339a815da8b398f,
        0x2c6d4e4511657e1e,
    ],
    [
        0x63e7cb4906ffc93f,
        0xf070bb00e28a193d,
        0xad1715b02e5713b5,
        0x4b5371495990693f,
    ],
];

/// The zero field element.
pub const FR_ZERO: fr_t = fr_t { l: [0, 0, 0, 0] };

/// This is 1 in Blst's `blst_fr` limb representation. Crazy but true.
pub const FR_ONE: fr_t = fr_t {
    l: [
        0x00000001fffffffe,
        0x5884b7fa00034802,
        0x998c4fefecbc4ff5,
        0x1824b159acc5056f,
    ],
};

================
File: src/kzg.rs
================
use crate::consts::*;
use crate::utils::*;
use blst::*;
use blst::{blst_fr as fr_t, blst_p1 as g1_t, blst_p2 as g2_t};
use std::fs::File;
use std::path::Path;

use BLST_ERROR::BLST_SUCCESS;

#[derive(Debug)]
pub enum Error {
    /// The supplied data is invalid in some way.
    BadArgs(String),
    /// Internal error - this should never occur.
    InternalError,
    /// The provided bytes are of incorrect length.
    InvalidBytesLength(String),
    /// Error when converting from hex to bytes.
    InvalidHexFormat(String),
    /// The provided trusted setup params are invalid.
    InvalidTrustedSetup(String),
}

/**
 * Stores the setup and parameters needed for computing KZG proofs.
 */
#[derive(Debug, Default)]
pub struct KzgSettings {
    /** The length of `roots_of_unity`, a power of 2. */
    max_width: u64,
    /** Powers of the primitive root of unity determined by
     * `SCALE2_ROOT_OF_UNITY` in bit-reversal permutation order,
     * length `max_width`. */
    roots_of_unity: Vec<fr_t>,
    /** G1 group elements from the trusted setup,
     * in Lagrange form bit-reversal permutation. */
    g1_values: Vec<g1_t>,
    /** G2 group elements from the trusted setup. */
    g2_values: Vec<g2_t>,
}

impl KzgSettings {
    /// Initializes a trusted setup from `FIELD_ELEMENTS_PER_BLOB` g1 points
    /// and 65 g2 points in byte format.
    pub fn load_trusted_setup(
        g1_bytes: Vec<[u8; BYTES_PER_G1]>,
        g2_bytes: Vec<[u8; BYTES_PER_G2]>,
    ) -> Result<Self, Error> {
        if g1_bytes.len() != FIELD_ELEMENTS_PER_BLOB {
            return Err(Error::InvalidTrustedSetup(format!(
                "Invalid number of g1 points in trusted setup. Expected {} got {}",
                FIELD_ELEMENTS_PER_BLOB,
                g1_bytes.len()
            )));
        }
        if g2_bytes.len() != TRUSTED_SETUP_NUM_G2_POINTS {
            return Err(Error::InvalidTrustedSetup(format!(
                "Invalid number of g2 points in trusted setup. Expected {} got {}",
                TRUSTED_SETUP_NUM_G2_POINTS,
                g2_bytes.len()
            )));
        }

        let g1_points = g1_bytes.into_iter().fold(vec![], |mut acc, x| {
            acc.extend_from_slice(&x);
            acc
        });
        let g2_points = g2_bytes.into_iter().fold(vec![], |mut acc, x| {
            acc.extend_from_slice(&x);
            acc
        });
        load_trusted_setup(
            g1_points,
            g2_points,
            FIELD_ELEMENTS_PER_BLOB,
            TRUSTED_SETUP_NUM_G2_POINTS,
        )
    }
}

/// Converts a hex string (with or without the 0x prefix) to bytes.
pub fn hex_to_bytes(hex_str: &str) -> Result<Vec<u8>, Error> {
    let trimmed_str = hex_str.strip_prefix("0x").unwrap_or(hex_str);
    hex::decode(trimmed_str)
        .map_err(|e| Error::InvalidHexFormat(format!("Failed to decode hex: {}", e)))
}

#[derive(Debug, Clone, PartialEq)]
struct Polynomial {
    evals: Box<[fr_t; FIELD_ELEMENTS_PER_BLOB]>,
}

impl Default for Polynomial {
    fn default() -> Self {
        Self {
            evals: Box::new([fr_t::default(); FIELD_ELEMENTS_PER_BLOB]),
        }
    }
}

#[derive(Default, Debug, Copy, Clone, PartialEq)]
pub struct Bytes32 {
    pub(crate) bytes: [u8; 32],
}

impl Bytes32 {
    pub fn from_bytes(b: &[u8]) -> Result<Self, Error> {
        if b.len() != 32 {
            return Err(Error::BadArgs(format!(
                "Bytes32 length error. Expected 32, got {}",
                b.len()
            )));
        }
        let mut arr = [0; 32];
        arr.copy_from_slice(b);
        Ok(Bytes32 { bytes: arr })
    }

    pub fn from_hex(hex_str: &str) -> Result<Self, Error> {
        Self::from_bytes(&hex_to_bytes(hex_str)?)
    }
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub struct Bytes48 {
    pub(crate) bytes: [u8; 48],
}

impl Bytes48 {
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {
        if bytes.len() != 48 {
            return Err(Error::InvalidBytesLength(format!(
                "Invalid byte length. Expected {} got {}",
                32,
                bytes.len(),
            )));
        }
        let mut new_bytes = [0; 48];
        new_bytes.copy_from_slice(bytes);
        Ok(Self { bytes: new_bytes })
    }

    pub fn from_hex(hex_str: &str) -> Result<Self, Error> {
        Self::from_bytes(&hex_to_bytes(hex_str)?)
    }
}

impl Default for Bytes48 {
    fn default() -> Self {
        Self { bytes: [0; 48] }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct Blob {
    bytes: Box<[u8; BYTES_PER_BLOB]>,
}

impl Blob {
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {
        if bytes.len() != BYTES_PER_BLOB {
            return Err(Error::InvalidBytesLength(format!(
                "Invalid byte length. Expected {} got {}",
                BYTES_PER_BLOB,
                bytes.len(),
            )));
        }
        let mut new_bytes = [0; BYTES_PER_BLOB];
        new_bytes.copy_from_slice(bytes);
        Ok(Self {
            bytes: Box::new(new_bytes),
        })
    }

    pub fn from_hex(hex_str: &str) -> Result<Self, Error> {
        Self::from_bytes(&hex_to_bytes(hex_str)?)
    }
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub struct KzgCommitment(pub Bytes48);

impl KzgCommitment {
    pub fn from_hex(hex_str: &str) -> Result<Self, Error> {
        Ok(Self(Bytes48::from_bytes(&hex_to_bytes(hex_str)?)?))
    }

    pub fn to_bytes(self) -> [u8; BYTES_PER_COMMITMENT] {
        self.0.bytes
    }
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub struct KzgProof(pub Bytes48);

impl KzgProof {
    pub fn from_hex(hex_str: &str) -> Result<Self, Error> {
        Ok(Self(Bytes48::from_bytes(&hex_to_bytes(hex_str)?)?))
    }

    pub fn to_bytes(self) -> [u8; BYTES_PER_PROOF] {
        self.0.bytes
    }
}

impl From<[u8; BYTES_PER_COMMITMENT]> for KzgCommitment {
    fn from(value: [u8; BYTES_PER_COMMITMENT]) -> Self {
        Self(Bytes48 { bytes: value })
    }
}

impl From<[u8; BYTES_PER_PROOF]> for KzgProof {
    fn from(value: [u8; BYTES_PER_PROOF]) -> Self {
        Self(Bytes48 { bytes: value })
    }
}

impl From<[u8; BYTES_PER_BLOB]> for Blob {
    fn from(value: [u8; BYTES_PER_BLOB]) -> Self {
        Self {
            bytes: Box::new(value),
        }
    }
}

impl From<[u8; 32]> for Bytes32 {
    fn from(value: [u8; 32]) -> Self {
        Self { bytes: value }
    }
}

impl From<[u8; 48]> for Bytes48 {
    fn from(value: [u8; 48]) -> Self {
        Self { bytes: value }
    }
}

use std::ops::{Deref, DerefMut};

impl Deref for Bytes32 {
    type Target = [u8; 32];
    fn deref(&self) -> &Self::Target {
        &self.bytes
    }
}

impl Deref for Bytes48 {
    type Target = [u8; 48];
    fn deref(&self) -> &Self::Target {
        &self.bytes
    }
}

impl Deref for Blob {
    type Target = [u8; BYTES_PER_BLOB];
    fn deref(&self) -> &Self::Target {
        &self.bytes
    }
}

impl DerefMut for Blob {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.bytes
    }
}

impl Deref for KzgProof {
    type Target = [u8; BYTES_PER_PROOF];
    fn deref(&self) -> &Self::Target {
        &self.0.bytes
    }
}

impl Deref for KzgCommitment {
    type Target = [u8; BYTES_PER_COMMITMENT];
    fn deref(&self) -> &Self::Target {
        &self.0.bytes
    }
}

/// Deserialize a `Blob` (array of bytes) into a `Polynomial` (array of field elements).
fn blob_to_polynomial(blob: &Blob) -> Result<Polynomial, Error> {
    let mut poly = Polynomial::default();
    for i in 0..FIELD_ELEMENTS_PER_BLOB {
        let start_bytes = i * BYTES_PER_FIELD_ELEMENT;
        let end_bytes = start_bytes + BYTES_PER_FIELD_ELEMENT;
        let field_bytes = Bytes32::from_bytes(&blob.bytes[start_bytes..end_bytes])?;
        poly.evals[i] = bytes_to_bls_field(&field_bytes)?;
    }
    Ok(poly)
}

/// Return the Fiat-Shamir challenge required to verify `blob` and
/// `commitment`.
///
/// Note: using commitment_bytes instead of `g1_t` like the c code since
/// we seem to be doing unnecessary conversions.
fn compute_challenge(blob: &Blob, commitment_bytes: &Bytes48) -> Result<fr_t, Error> {
    let mut bytes = vec![0u8; CHALLENGE_INPUT_SIZE];
    let mut offset = 0;

    /* Copy domain separator */
    bytes[offset..offset + DOMAIN_STR_LENGTH]
        .copy_from_slice(FIAT_SHAMIR_PROTOCOL_DOMAIN.as_bytes());
    offset += DOMAIN_STR_LENGTH;

    /* Copy polynomial degree (16-bytes, big-endian) */
    bytes[offset..offset + std::mem::size_of::<u64>()]
        .copy_from_slice(bytes_from_uint64(0u64).as_slice());
    offset += std::mem::size_of::<u64>();
    bytes[offset..offset + std::mem::size_of::<u64>()]
        .copy_from_slice(bytes_from_uint64(FIELD_ELEMENTS_PER_BLOB as u64).as_slice());
    offset += std::mem::size_of::<u64>();

    /* Copy blob */
    bytes[offset..offset + BYTES_PER_BLOB].copy_from_slice(blob.bytes.as_slice());
    offset += BYTES_PER_BLOB;

    /* Copy commitment */
    // Check if commitment bytes are a valid g1 point
    if bytes_to_kzg_commitment(commitment_bytes).is_err() {
        return Err(Error::BadArgs("Invalid commitment bytes".to_string()));
    }
    bytes[offset..offset + BYTES_PER_COMMITMENT].copy_from_slice(commitment_bytes.bytes.as_slice());
    offset += BYTES_PER_COMMITMENT;

    /* Make sure we wrote the entire buffer */
    assert_eq!(offset, CHALLENGE_INPUT_SIZE);

    let mut eval_challenge = Bytes32::default();
    unsafe {
        blst_sha256(
            eval_challenge.bytes.as_mut_ptr(),
            bytes.as_ptr(),
            CHALLENGE_INPUT_SIZE,
        );
    }
    Ok(hash_to_bls_field(&eval_challenge))
}

///////////////////////////////////////////////////////////////////////////////
// Polynomials Functions
///////////////////////////////////////////////////////////////////////////////

/// Evaluate a polynomial in evaluation form at a given point.
fn evaluate_polynomial_in_evaluation_form(
    p: &Polynomial,
    x: &fr_t,
    s: &KzgSettings,
) -> Result<fr_t, Error> {
    let mut inverses_in = [fr_t::default(); FIELD_ELEMENTS_PER_BLOB];
    let mut tmp = blst_fr::default();
    for i in 0..FIELD_ELEMENTS_PER_BLOB {
        /*
         * If the point to evaluate at is one of the evaluation points by which
         * the polynomial is given, we can just return the result directly.
         * Note that special-casing this is necessary, as the formula below
         * would divide by zero otherwise.
         */
        if fr_equal(x, &s.roots_of_unity[i]) {
            return Ok(p.evals[i]);
        }
        unsafe {
            blst_fr_sub(&mut tmp, x, &s.roots_of_unity[i]);
            inverses_in[i] = tmp;
        }
    }
    let inverses = fr_batch_inv(&inverses_in)?;

    let mut res = FR_ZERO;
    let mut tmp = fr_t::default();
    for i in 0..FIELD_ELEMENTS_PER_BLOB {
        unsafe {
            blst_fr_mul(&mut tmp, &inverses[i], &s.roots_of_unity[i]);
            blst_fr_mul(&mut tmp, &tmp, &p.evals[i]);
            blst_fr_add(&mut res, &res, &tmp);
        }
    }
    res = fr_div(res, fr_from_uint64(FIELD_ELEMENTS_PER_BLOB as u64));
    unsafe {
        blst_fr_sub(
            &mut tmp,
            &fr_pow(*x, FIELD_ELEMENTS_PER_BLOB as u64),
            &FR_ONE,
        );
        blst_fr_mul(&mut res, &res, &tmp);
    }
    Ok(res)
}

///////////////////////////////////////////////////////////////////////////////
// KZG Functions
///////////////////////////////////////////////////////////////////////////////

/// Compute a KZG commitment from a polynomial.
fn poly_to_kzg_commitment(p: &Polynomial, s: &KzgSettings) -> Result<g1_t, Error> {
    g1_lincomb_fast(&s.g1_values, p.evals.as_slice())
}

/// Convert a blob to a KZG commitment.
fn blob_to_kzg_commitment(blob: &Blob, s: &KzgSettings) -> Result<KzgCommitment, Error> {
    let poly = blob_to_polynomial(blob)?;
    let commitment = poly_to_kzg_commitment(&poly, s)?;
    let commitment_bytes = bytes_from_g1(&commitment);
    Ok(KzgCommitment(commitment_bytes))
}

/// Helper function: Verify KZG proof claiming that `p(z) == y`.
fn verify_kzg_proof_impl(
    commitment: &g1_t,
    z: &fr_t,
    y: &fr_t,
    proof: &g1_t,
    s: &KzgSettings,
) -> bool {
    /* Calculate: X_minus_z */
    let x_g2 = g2_mul(&G2_GENERATOR, z);
    let x_minus_z = g2_sub(&s.g2_values[1], &x_g2);

    /* Calculate: P_minus_y */
    let y_g1 = g1_mul(&G1_GENERATOR, y);
    let p_minus_y = g1_sub(commitment, &y_g1);

    /* Verify: P - y = Q * (X - z) */
    pairings_verify(&p_minus_y, &G2_GENERATOR, proof, &x_minus_z)
}

/// Verify a KZG proof claiming that `p(z) == y`.
fn verify_kzg_proof(
    commitment_bytes: &KzgCommitment,
    z_bytes: &Bytes32,
    y_bytes: &Bytes32,
    proof_bytes: &KzgProof,
    s: &KzgSettings,
) -> Result<bool, Error> {
    let commitment = bytes_to_kzg_commitment(&commitment_bytes.0)?;
    let z = bytes_to_bls_field(z_bytes)?;
    let y = bytes_to_bls_field(y_bytes)?;
    let proof = bytes_to_kzg_proof(&proof_bytes.0)?;

    /* Call helper to do pairings check */
    Ok(verify_kzg_proof_impl(&commitment, &z, &y, &proof, s))
}

/// Compute KZG proof for polynomial in Lagrange form at position `z`.
fn compute_kzg_proof(
    blob: &Blob,
    z_bytes: &Bytes32,
    s: &KzgSettings,
) -> Result<(KzgProof, Bytes32), Error> {
    let poly = blob_to_polynomial(blob)?;
    let fr_z = bytes_to_bls_field(z_bytes)?;

    let (proof, fr_y) = compute_kzg_proof_impl(&poly, &fr_z, s)?;
    let y_bytes = bytes_from_bls_field(&fr_y);
    Ok((proof, y_bytes))
}

/// Helper function for `compute_kzg_proof()` and
/// `compute_blob_kzg_proof()`.
fn compute_kzg_proof_impl(
    polynomial: &Polynomial,
    z: &fr_t,
    s: &KzgSettings,
) -> Result<(KzgProof, fr_t), Error> {
    let mut q = Polynomial::default();
    let y_out = evaluate_polynomial_in_evaluation_form(polynomial, z, s)?;
    let mut inverses_in = [fr_t::default(); FIELD_ELEMENTS_PER_BLOB];
    let mut m = 0usize;
    for i in 0..FIELD_ELEMENTS_PER_BLOB {
        if fr_equal(z, &s.roots_of_unity[i]) {
            /* We are asked to compute a KZG proof inside the domain */
            m = i + 1;
            inverses_in[i] = FR_ONE;
            continue;
        }
        // (p_i - y) / (_i - z)
        unsafe {
            blst_fr_sub(&mut q.evals[i], &polynomial.evals[i], &y_out);
            blst_fr_sub(&mut inverses_in[i], &s.roots_of_unity[i], z);
        }
    }

    let mut inverses = fr_batch_inv(&inverses_in)?;

    for i in 0..FIELD_ELEMENTS_PER_BLOB {
        unsafe {
            blst_fr_mul(&mut q.evals[i], &q.evals[i], &inverses[i]);
        }
    }

    let mut tmp = fr_t::default();
    /* _{m-1} == z */
    if m != 0 {
        m -= 1;
        q.evals[m] = FR_ZERO;
        for i in 0..FIELD_ELEMENTS_PER_BLOB {
            if i == m {
                continue;
            }
            unsafe {
                /* Build denominator: z * (z - _i) */
                blst_fr_sub(&mut tmp, z, &s.roots_of_unity[i]);
                blst_fr_mul(&mut inverses_in[i], &tmp, z);
            }
        }

        inverses = fr_batch_inv(&inverses_in)?;

        for i in 0..FIELD_ELEMENTS_PER_BLOB {
            if i == m {
                continue;
            }
            unsafe {
                /* Build numerator: _i * (p_i - y) */
                blst_fr_sub(&mut tmp, &polynomial.evals[i], &y_out);
                blst_fr_mul(&mut tmp, &tmp, &s.roots_of_unity[i]);
                /* Do the division: (p_i - y) * _i / (z * (z - _i)) */
                blst_fr_mul(&mut tmp, &tmp, &inverses[i]);
                blst_fr_add(&mut q.evals[m], &q.evals[m], &tmp);
            }
        }
    }
    let out_g1 = g1_lincomb_fast(&s.g1_values, q.evals.as_slice())?;

    let proof = bytes_from_g1(&out_g1);
    Ok((KzgProof(proof), y_out))
}

/// Given a blob and a commitment, return the KZG proof that is used to verify
/// it against the commitment. This function does not verify that the commitment
/// is correct with respect to the blob.
fn compute_blob_kzg_proof(
    blob: &Blob,
    commitment_bytes: &KzgCommitment,
    s: &KzgSettings,
) -> Result<KzgProof, Error> {
    let poly = blob_to_polynomial(blob)?;
    /* Compute the challenge for the given blob/commitment */
    let evaluation_challenge_fr = compute_challenge(blob, &commitment_bytes.0)?;

    /* Call helper function to compute proof and y */
    compute_kzg_proof_impl(&poly, &evaluation_challenge_fr, s).map(|(proof, _)| proof)
}

/// Given a blob and its proof, verify that it corresponds to the provided commitment.
fn verify_blob_kzg_proof(
    blob: &Blob,
    commitment_bytes: &KzgCommitment,
    proof_bytes: &KzgProof,
    s: &KzgSettings,
) -> Result<bool, Error> {
    let poly = blob_to_polynomial(blob)?;
    let commitment = bytes_to_kzg_commitment(&commitment_bytes.0)?;
    let proof = bytes_to_kzg_proof(&proof_bytes.0)?;
    /* Compute challenge for the blob/commitment */
    let eveluation_challenge_fr = compute_challenge(blob, &commitment_bytes.0)?;

    /* Evaluate challenge to get y */
    let y_fr = evaluate_polynomial_in_evaluation_form(&poly, &eveluation_challenge_fr, s)?;

    Ok(verify_kzg_proof_impl(
        &commitment,
        &eveluation_challenge_fr,
        &y_fr,
        &proof,
        s,
    ))
}

/// Helper function for `verify_blob_kzg_proof_batch()`: actually perform the
/// verification.
///
/// NOTE: This function assumes that `n` is trusted and that all input arrays
/// contain `n` elements. `n` should be the actual size of the arrays and not
/// read off a length field in the protocol.
///
/// This function only works for `n > 0`.
fn verify_kzg_proof_batch(
    commitments_g1: &[g1_t],
    zs_fr: &[fr_t],
    ys_fr: &[fr_t],
    proofs_g1: &[g1_t],
    s: &KzgSettings,
) -> Result<bool, Error> {
    let n = commitments_g1.len();

    if n == 0 {
        return Err(Error::BadArgs(
            "verify_kzg_proof_batch empty input".to_string(),
        ));
    }

    /* Compute the random lincomb challenges */
    let r_powers = compute_r_powers(commitments_g1, zs_fr, ys_fr, proofs_g1)?;

    let mut c_minus_y: Vec<_> = (0..n).map(|_| g1_t::default()).collect();
    let mut r_times_z: Vec<_> = (0..n).map(|_| fr_t::default()).collect();

    /* Compute \sum r^i * Proof_i */
    let proof_lincomb = g1_lincomb_naive(proofs_g1, &r_powers)?;

    for i in 0..n {
        /* Get [y_i] */
        let ys_encrypted = g1_mul(&G1_GENERATOR, &ys_fr[i]);
        /* Get C_i - [y_i] */
        c_minus_y[i] = g1_sub(&commitments_g1[i], &ys_encrypted);
        /* Get r^i * z_i */
        unsafe {
            blst_fr_mul(&mut r_times_z[i], &r_powers[i], &zs_fr[i]);
        }
    }
    /* Get \sum r^i z_i Proof_i */
    let proof_z_lincomb = g1_lincomb_naive(proofs_g1, &r_times_z)?;

    let c_minus_y_lincomb = g1_lincomb_naive(&c_minus_y, &r_powers)?;

    let mut rhs_g1 = blst_p1::default();
    /* Get C_minus_y_lincomb + proof_z_lincomb */
    unsafe {
        blst_p1_add_or_double(&mut rhs_g1, &c_minus_y_lincomb, &proof_z_lincomb);
    }

    /* Do the pairing check! */
    let res = pairings_verify(&proof_lincomb, &s.g2_values[1], &rhs_g1, &G2_GENERATOR);
    Ok(res)
}

/// Given a list of blobs and blob KZG proofs, verify that they correspond to the
/// provided commitments.
///
/// NOTE: This function assumes that `n` is trusted and that all input arrays
/// contain `n` elements. `n` should be the actual size of the arrays and not
/// read off a length field in the protocol.
///
/// This function accepts if called with `n==0`.
fn verify_blob_kzg_proof_batch(
    blobs: &[Blob],
    commitment_bytes: &[KzgCommitment],
    proof_bytes: &[KzgProof],
    s: &KzgSettings,
) -> Result<bool, Error> {
    let n = blobs.len();
    if blobs.len() != commitment_bytes.len() || commitment_bytes.len() != proof_bytes.len() {
        return Err(Error::BadArgs(format!(
            "Inconsistent lengths, blobs: {}, commitments: {}, proofs: {}",
            blobs.len(),
            commitment_bytes.len(),
            proof_bytes.len()
        )));
    }
    /* Exit early if we are given zero blobs */
    if n == 0 {
        return Ok(true);
    }

    /* For a single blob, just do a regular single verification */
    if n == 1 {
        return verify_blob_kzg_proof(&blobs[0], &commitment_bytes[0], &proof_bytes[0], s);
    }
    // Note: Potentially paralellizable
    /* Convert each commitment to a g1 point */
    let mut commitments_g1: Vec<_> = (0..n).map(|_| g1_t::default()).collect();

    /* Convert each proof to a g1 point */
    let mut proofs_g1: Vec<_> = (0..n).map(|_| g1_t::default()).collect();

    let mut evaluation_challenges_fr: Vec<_> = (0..n).map(|_| fr_t::default()).collect();
    let mut ys_fr: Vec<_> = (0..n).map(|_| fr_t::default()).collect();

    for i in 0..n {
        /* Convert each commitment to a g1 point */
        commitments_g1[i] = bytes_to_kzg_commitment(&commitment_bytes[i].0)?;
        /* Convert each blob from bytes to a poly */
        let polynomial = blob_to_polynomial(&blobs[i])?;

        evaluation_challenges_fr[i] = compute_challenge(&blobs[i], &commitment_bytes[i].0)?;

        ys_fr[i] =
            evaluate_polynomial_in_evaluation_form(&polynomial, &evaluation_challenges_fr[i], s)?;

        proofs_g1[i] = bytes_to_kzg_proof(&proof_bytes[i].0)?;
    }

    let res = verify_kzg_proof_batch(
        &commitments_g1,
        &evaluation_challenges_fr,
        &ys_fr,
        &proofs_g1,
        s,
    )?;
    Ok(res)
}

///////////////////////////////////////////////////////////////////////////////
// Trusted Setup Functions
///////////////////////////////////////////////////////////////////////////////

/// Reverse the bit order in a 32 bit integer.
fn reverse_bits(mut n: u32, order: u32) -> u32 {
    assert!(order.is_power_of_two());
    let order = order.ilog2();
    let mut result = 0;
    for _ in 0..order {
        result <<= 1;
        result |= n & 1;
        n >>= 1;
    }
    result
}

/// Reorder an array in reverse bit order of its indices.
///
/// NOTE: Unline the C code which swaps in place, this function returns a new vector.
/// We leverage rust generics to accept a vector of arbitrary type instead of dealing with void * pointers like in the
/// C code.
fn bit_reversal_permutation<T: Copy>(values: Vec<T>, n: usize) -> Result<Vec<T>, Error> {
    if values.is_empty() || n >> 32 != 0 || !n.is_power_of_two() || n.ilog2() == 0 {
        return Err(Error::BadArgs(
            "bit_reversal_permutation: invalid args".to_string(),
        ));
    }

    let mut res = Vec::with_capacity(n);
    for i in 0..n {
        let bit_reversed_i = reverse_bits(i as u32, n as u32);
        res.push(values[bit_reversed_i as usize]);
    }

    Ok(res)
}

/// Generate powers of a root of unity in the field.
fn expand_root_of_unity(root: &fr_t, width: u64) -> Result<Vec<fr_t>, Error> {
    let mut res: Vec<blst_fr> = (0..width + 1).map(|_| blst_fr::default()).collect();
    res[0] = FR_ONE;
    res[1] = *root;

    let mut i = 2usize;
    let mut tmp = blst_fr::default();

    while !fr_is_one(&res[i - 1]) {
        if i > width as usize {
            return Err(Error::BadArgs(
                "expand_root_of_unity: i > width".to_string(),
            ));
        }
        unsafe {
            blst_fr_mul(&mut tmp, &res[i - 1], root);
        }
        res[i] = tmp;
        i += 1;
    }

    if !fr_is_one(&res[width as usize]) {
        return Err(Error::BadArgs(
            "expand_root_of_unity: assertion failed".to_string(),
        ));
    }
    Ok(res)
}

/// Initialize the roots of unity.
fn compute_roots_of_unity(max_scale: u32) -> Result<Vec<fr_t>, Error> {
    /* Calculate the max width */
    let max_width = 1 << max_scale;

    /* Get the root of unity */
    if max_scale >= SCALE2_ROOT_OF_UNITY.len() as u32 {
        return Err(Error::BadArgs(
            "compute_roots_of_unity: max_scale too large".to_string(),
        ));
    }

    let mut root_of_unity = fr_t::default();
    unsafe {
        blst_fr_from_uint64(
            &mut root_of_unity,
            SCALE2_ROOT_OF_UNITY[max_scale as usize].as_ptr(),
        );
    }

    /*
     * Allocate an array to store the expanded roots of unity. We do this
     * instead of re-using roots_of_unity_out because the expansion requires
     * max_width+1 elements.
     */

    /* Populate the roots of unity */
    let mut expanded_roots = expand_root_of_unity(&root_of_unity, max_width)?;
    /* Copy all but the last root to the roots of unity */
    // NOTE: deviating from c code here
    expanded_roots.pop();

    /* Permute the roots of unity */
    let roots_of_unity_out = bit_reversal_permutation(expanded_roots, max_width as usize)?;

    Ok(roots_of_unity_out)
}

/// Basic sanity check that the trusted setup was loaded in Lagrange form.
fn is_trusted_setup_in_lagrange_form(s: &KzgSettings) -> Result<(), Error> {
    /* Trusted setup is too small; we can't work with this */
    if s.g1_values.len() < 2 || s.g2_values.len() < 2 {
        return Err(Error::BadArgs(
            "is_trusted_setup_in_lagrange_form: invalid args".to_string(),
        ));
    }

    /*
     * If the following pairing equation checks out:
     *     e(G1_SETUP[1], G2_SETUP[0]) ?= e(G1_SETUP[0], G2_SETUP[1])
     * then the trusted setup was loaded in monomial form.
     * If so, error out since we want the trusted setup in Lagrange form.
     */
    let is_monomial_form = pairings_verify(
        &s.g1_values[1],
        &s.g2_values[0],
        &s.g1_values[0],
        &s.g2_values[1],
    );

    if is_monomial_form {
        Err(Error::BadArgs(
            "is_trusted_setup_in_lagrange_form: not in monomial form".to_string(),
        ))
    } else {
        Ok(())
    }
}

/// Load trusted setup into a KzgSettings struct.
fn load_trusted_setup(
    g1_bytes: Vec<u8>,
    g2_bytes: Vec<u8>,
    n1: usize,
    n2: usize,
) -> Result<KzgSettings, Error> {
    let mut kzg_settings = KzgSettings::default();

    /* Sanity check in case this is called directly */

    if n1 != FIELD_ELEMENTS_PER_BLOB || n2 != TRUSTED_SETUP_NUM_G2_POINTS {
        return Err(Error::BadArgs(
            "load_trusted_setup invalid params".to_string(),
        ));
    }

    /* 1<<max_scale is the smallest power of 2 >= n1 */
    let mut max_scale = 0;
    while (1 << max_scale) < n1 {
        max_scale += 1;
    }

    /* Set the max_width */
    kzg_settings.max_width = 1 << max_scale;

    /* Convert all g1 bytes to g1 points */
    for i in 0..n1 {
        let mut g1_affine = blst_p1_affine::default();
        unsafe {
            let err = blst_p1_uncompress(&mut g1_affine, &g1_bytes[BYTES_PER_G1 * i]);
            if err != BLST_SUCCESS {
                return Err(Error::BadArgs(
                    "load_trusted_setup Invalid g1 bytes".to_string(),
                ));
            }
            let mut tmp = g1_t::default();
            blst_p1_from_affine(&mut tmp, &g1_affine);
            kzg_settings.g1_values.push(tmp);
        }
    }
    /* Convert all g2 bytes to g2 points */
    for i in 0..n2 {
        let mut g2_affine = blst_p2_affine::default();
        unsafe {
            let err = blst_p2_uncompress(&mut g2_affine, &g2_bytes[BYTES_PER_G2 * i]);
            if err != BLST_SUCCESS {
                return Err(Error::BadArgs(
                    "load_trusted_setup invalid g2 bytes".to_string(),
                ));
            }
            let mut tmp = g2_t::default();
            blst_p2_from_affine(&mut tmp, &g2_affine);
            kzg_settings.g2_values.push(tmp);
        }
    }

    /* Make sure the trusted setup was loaded in Lagrange form */
    is_trusted_setup_in_lagrange_form(&kzg_settings)?;

    /* Compute roots of unity and permute the G1 trusted setup */
    let roots_of_unity = compute_roots_of_unity(max_scale)?;
    kzg_settings.roots_of_unity = roots_of_unity;
    let bit_reversed_permutation = bit_reversal_permutation(kzg_settings.g1_values, n1)?;
    kzg_settings.g1_values = bit_reversed_permutation;

    Ok(kzg_settings)
}

/// Load trusted setup from a file.
///
/// The file format is `n1 n2 g1_1 g1_2 ... g1_n1 g2_1 ... g2_n2` where
/// the first two numbers are in decimal and the remainder are hexstrings
/// and any whitespace can be used as separators.
fn load_trusted_setup_file<P: AsRef<Path>>(trusted_setup_file: P) -> Result<KzgSettings, Error> {
    let file = File::open(trusted_setup_file).map_err(|e| {
        Error::InvalidTrustedSetup(format!("Failed to open trusted setup file: {:?}", e))
    })?;

    use std::io::{BufRead, BufReader};
    let reader = BufReader::new(file);

    let mut lines = reader.lines();

    let Some(Ok(field_elements_per_blob)) = lines.next() else {
        return Err(Error::InvalidTrustedSetup(
            "Trusted setup file does not contain valid FIELD_ELEMENTS_PER_BLOB on line 1"
                .to_string(),
        ));
    };
    let field_elements_per_blob: usize = field_elements_per_blob.parse().map_err(|_| {
        Error::InvalidTrustedSetup("FIELD_ELEMENTS_PER_BLOB is not a valid integer".to_string())
    })?;
    if field_elements_per_blob != FIELD_ELEMENTS_PER_BLOB {
        return Err(Error::InvalidTrustedSetup(format!(
            "Invalid trusted setup for chosen preset. \
            Selected preset FIELD_ELEMENTS_PER_BLBO: {} \
            FIELD_ELEMENTS_PER_BLOB value in file: {}",
            FIELD_ELEMENTS_PER_BLOB, field_elements_per_blob
        )));
    }

    let Some(Ok(num_g2_points)) = lines.next() else {
        return Err(Error::InvalidTrustedSetup(
            "Trusted setup file does not contain valid NUM_G2_POINTS on line 2".to_string(),
        ));
    };
    let num_g2_points: usize = num_g2_points.parse().map_err(|_| {
        Error::InvalidTrustedSetup("FIELD_ELEMENTS_PER_BLOB is not a valid integer".to_string())
    })?;

    if num_g2_points != 65 {
        return Err(Error::InvalidTrustedSetup(format!(
            "Invalid trusted setup for chosen preset. \
            Selected preset NUM_G2_POINTS: {} \
            NUM_G2_POINTS value in file: {}",
            65, num_g2_points
        )));
    }

    let mut g1_bytes = Vec::new();
    for _ in 0..field_elements_per_blob {
        let g1_point = hex_to_bytes(
            &lines
                .next()
                .ok_or_else(|| {
                    Error::InvalidTrustedSetup("Invalid number of g1 points in file".to_string())
                })?
                .map_err(|_| Error::InvalidTrustedSetup("Invalid g1 point string".to_string()))?,
        )?;
        g1_bytes.extend_from_slice(&g1_point);
    }

    let mut g2_bytes = Vec::new();
    for _ in 0..num_g2_points {
        let g2_point = hex_to_bytes(
            &lines
                .next()
                .ok_or_else(|| {
                    Error::InvalidTrustedSetup("Invalid number of g2 points in file".to_string())
                })?
                .map_err(|_| Error::InvalidTrustedSetup("Invalid g2 point string".to_string()))?,
        )?;
        g2_bytes.extend_from_slice(&g2_point);
    }

    load_trusted_setup(g1_bytes, g2_bytes, field_elements_per_blob, num_g2_points)
}

/// A wrapper struct that exposes interface functions from the C code
/// as struct methods.
pub struct Kzg;

impl Kzg {
    /// Loads a trusted setup in the format described below and
    /// returns a `KzgSettings` struct.
    ///
    /// The file format is as follows:
    ///
    /// FIELD_ELEMENTS_PER_BLOB
    /// 65 # This is fixed and is used for providing multiproofs up to 64 field elements.
    /// `FIELD_ELEMENT_PER_BLOB` lines with each line containing a hex encoded g1 byte value.
    /// 65 lines with each line containing a hex encoded g2 byte value.
    pub fn load_trusted_setup_file<P: AsRef<Path>>(
        trusted_setup_file: P,
    ) -> Result<KzgSettings, Error> {
        load_trusted_setup_file(trusted_setup_file)
    }

    /// Loads a trusted setup and returns a `KzgSettings` struct.
    ///
    /// The `g1_bytes` and `g2_bytes` need to be extracted and parsed from a file
    /// and then passed into this function.
    pub fn load_trusted_setup(
        g1_bytes: Vec<[u8; BYTES_PER_G1]>,
        g2_bytes: Vec<[u8; BYTES_PER_G2]>,
    ) -> Result<KzgSettings, Error> {
        KzgSettings::load_trusted_setup(g1_bytes, g2_bytes)
    }

    /// Return the `KzgCommitment` corresponding to the `Blob`.
    pub fn blob_to_kzg_commitment(blob: &Blob, s: &KzgSettings) -> Result<KzgCommitment, Error> {
        blob_to_kzg_commitment(blob, s)
    }

    /// Compute the `KzgProof` given the `Blob` at the point corresponding to field element `z`.
    pub fn compute_kzg_proof(
        blob: &Blob,
        z_bytes: &Bytes32,
        s: &KzgSettings,
    ) -> Result<(KzgProof, Bytes32), Error> {
        compute_kzg_proof(blob, z_bytes, s)
    }

    /// Compute the `KzgProof` given the `Blob` and `KzgCommitment`.
    pub fn compute_blob_kzg_proof(
        blob: &Blob,
        commitment_bytes: &KzgCommitment,
        s: &KzgSettings,
    ) -> Result<KzgProof, Error> {
        compute_blob_kzg_proof(blob, commitment_bytes, s)
    }

    /// Verify a KZG proof claiming that `p(z) == y`.
    pub fn verify_kzg_proof(
        commitment_bytes: &KzgCommitment,
        z_bytes: &Bytes32,
        y_bytes: &Bytes32,
        proof_bytes: &KzgProof,
        s: &KzgSettings,
    ) -> Result<bool, Error> {
        verify_kzg_proof(commitment_bytes, z_bytes, y_bytes, proof_bytes, s)
    }

    /// Given a blob and its proof, verify that it corresponds to the provided commitment.
    pub fn verify_blob_kzg_proof(
        blob: &Blob,
        commitment_bytes: &KzgCommitment,
        proof_bytes: &KzgProof,
        s: &KzgSettings,
    ) -> Result<bool, Error> {
        verify_blob_kzg_proof(blob, commitment_bytes, proof_bytes, s)
    }

    /// Given a list of blobs and blob KZG proofs, verify that they correspond to the
    /// provided commitments.
    pub fn verify_blob_kzg_proof_batch(
        blobs: &[Blob],
        commitment_bytes: &[KzgCommitment],
        proof_bytes: &[KzgProof],
        s: &KzgSettings,
    ) -> Result<bool, Error> {
        verify_blob_kzg_proof_batch(blobs, commitment_bytes, proof_bytes, s)
    }

    /// Compute a single KZG multiproof for multiple points `zs` on the same polynomial `blob`.
    /// Returns the proof and the evaluations `ys = p(z_i)`.
    ///
    /// Limitations:
    /// - `zs.len()` must be > 0 and <= 64 (due to trusted setup size in G2).
    /// - None of the `z_i` may coincide with any root of unity in the evaluation domain
    ///   (to avoid division-by-zero in evaluation-form division). If this occurs, an error is returned.
    pub fn compute_multi_kzg_proof(
        blob: &Blob,
        zs: &[Bytes32],
        s: &KzgSettings,
    ) -> Result<(KzgProof, Vec<Bytes32>), Error> {
        compute_multi_kzg_proof(blob, zs, s)
    }

    /// Verify a single KZG multiproof for multiple points `(z_i, y_i)` against commitment `C`.
    /// See limitations in `compute_multi_kzg_proof` about `zs`.
    pub fn verify_multi_kzg_proof(
        commitment_bytes: &KzgCommitment,
        zs: &[Bytes32],
        ys: &[Bytes32],
        proof_bytes: &KzgProof,
        s: &KzgSettings,
    ) -> Result<bool, Error> {
        verify_multi_kzg_proof(commitment_bytes, zs, ys, proof_bytes, s)
    }
}

///////////////////////////////////////////////////////////////////////////////
// Multiproof (multi-point) helpers
///////////////////////////////////////////////////////////////////////////////

/// Build coefficients of Z(X) =  (X - z_i) in coefficient form (lowest degree first).
fn poly_from_roots_coeffs(zs: &[fr_t]) -> Result<Vec<fr_t>, Error> {
    if zs.is_empty() {
        return Err(Error::BadArgs(
            "poly_from_roots_coeffs empty input".to_string(),
        ));
    }
    let k = zs.len();
    let mut coeffs: Vec<fr_t> = Vec::with_capacity(k + 1);
    coeffs.push(FR_ONE); // start with 1
                         // Multiply by (X - z) for each root
    for zi in zs {
        let d = coeffs.len(); // current degree + 1
        let mut new_coeffs: Vec<fr_t> = (0..=d).map(|_| fr_t::default()).collect();
        // new[0] = -zi * a0
        unsafe {
            let mut neg_zi = fr_t::default();
            blst_fr_sub(&mut neg_zi, &FR_ZERO, zi);
            blst_fr_mul(&mut new_coeffs[0], &neg_zi, &coeffs[0]);
            // middle terms
            for j in 1..d {
                // new[j] = a_{j-1} - zi * a_j
                let mut t = fr_t::default();
                blst_fr_mul(&mut t, zi, &coeffs[j]);
                blst_fr_sub(&mut new_coeffs[j], &coeffs[j - 1], &t);
            }
            // highest degree term
            new_coeffs[d] = coeffs[d - 1];
        }
        coeffs = new_coeffs;
    }
    Ok(coeffs)
}

/// Compute I(_j) for each _j in the evaluation domain using barycentric formula:
/// I() = Z() * _i y_i / (( - z_i) Z'(z_i))
fn interpolant_evals_on_domain(
    zs: &[fr_t],
    ys: &[fr_t],
    s: &KzgSettings,
) -> Result<(Vec<fr_t>, Vec<fr_t>), Error> {
    let k = zs.len();
    if k == 0 || k != ys.len() {
        return Err(Error::BadArgs(
            "interpolant_evals_on_domain bad input".to_string(),
        ));
    }

    // Compute denom_i = Z'(z_i) = _{m!=i} (z_i - z_m)
    let mut denoms: Vec<fr_t> = (0..k).map(|_| fr_t::default()).collect();
    for i in 0..k {
        let mut acc = FR_ONE;
        for m in 0..k {
            if m == i {
                continue;
            }
            unsafe {
                let mut diff = fr_t::default();
                blst_fr_sub(&mut diff, &zs[i], &zs[m]);
                blst_fr_mul(&mut acc, &acc, &diff);
            }
        }
        if fr_is_zero(&acc) {
            return Err(Error::BadArgs(
                "duplicate z detected in multiproof".to_string(),
            ));
        }
        denoms[i] = acc;
    }
    let inv_denoms = fr_batch_inv(&denoms)?;

    let n = FIELD_ELEMENTS_PER_BLOB;
    let mut i_evals: Vec<fr_t> = (0..n).map(|_| fr_t::default()).collect();
    let mut z_evals: Vec<fr_t> = (0..n).map(|_| fr_t::default()).collect();

    // For each domain element _j, compute Z(_j) and I(_j)
    for j in 0..n {
        let w = &s.roots_of_unity[j];
        // denom terms (w - z_i)
        let mut diffs: Vec<fr_t> = (0..k).map(|_| fr_t::default()).collect();
        let mut prod = FR_ONE;
        for i in 0..k {
            unsafe {
                blst_fr_sub(&mut diffs[i], w, &zs[i]);
                if fr_is_zero(&diffs[i]) {
                    // z_i matches evaluation domain -> unsupported in this implementation
                    return Err(Error::BadArgs(
                        "z equals evaluation domain element (root of unity)".to_string(),
                    ));
                }
                blst_fr_mul(&mut prod, &prod, &diffs[i]);
            }
        }
        let inv_diffs = fr_batch_inv(&diffs)?;
        // sum_i y_i * inv_denoms[i] * inv_diffs[i]
        let mut sum = FR_ZERO;
        for i in 0..k {
            unsafe {
                let mut t = fr_t::default();
                blst_fr_mul(&mut t, &inv_denoms[i], &inv_diffs[i]);
                blst_fr_mul(&mut t, &t, &ys[i]);
                blst_fr_add(&mut sum, &sum, &t);
            }
        }
        // I(w) = Z(w) * sum
        unsafe {
            blst_fr_mul(&mut i_evals[j], &prod, &sum);
        }
        z_evals[j] = prod;
    }
    Ok((i_evals, z_evals))
}

/// Compute a single KZG multiproof for multiple points on the same polynomial
fn compute_multi_kzg_proof(
    blob: &Blob,
    zs_bytes: &[Bytes32],
    s: &KzgSettings,
) -> Result<(KzgProof, Vec<Bytes32>), Error> {
    if zs_bytes.is_empty() {
        return Err(Error::BadArgs(
            "compute_multi_kzg_proof empty zs".to_string(),
        ));
    }
    if zs_bytes.len() >= TRUSTED_SETUP_NUM_G2_POINTS as usize {
        return Err(Error::BadArgs("too many points for multiproof".to_string()));
    }

    let poly = blob_to_polynomial(blob)?;
    let k = zs_bytes.len();
    let mut zs: Vec<fr_t> = Vec::with_capacity(k);
    for z in zs_bytes {
        zs.push(bytes_to_bls_field(z)?);
    }

    // Compute ys = p(z_i)
    let mut ys: Vec<fr_t> = Vec::with_capacity(k);
    let mut ys_bytes: Vec<Bytes32> = Vec::with_capacity(k);
    for i in 0..k {
        let y = evaluate_polynomial_in_evaluation_form(&poly, &zs[i], s)?;
        ys.push(y);
        ys_bytes.push(bytes_from_bls_field(&y));
    }

    // Compute I(_j) and Z(_j)
    let (i_evals, z_evals) = interpolant_evals_on_domain(&zs, &ys, s)?;

    // q.evals[j] = (P(_j) - I(_j)) / Z(_j)
    let mut q = Polynomial::default();
    for j in 0..FIELD_ELEMENTS_PER_BLOB {
        let mut num = fr_t::default();
        unsafe {
            blst_fr_sub(&mut num, &poly.evals[j], &i_evals[j]);
        }
        q.evals[j] = fr_div(num, z_evals[j]);
    }

    let out_g1 = g1_lincomb_fast(&s.g1_values, q.evals.as_slice())?;
    let proof = KzgProof(bytes_from_g1(&out_g1));
    Ok((proof, ys_bytes))
}

/// Verify a single KZG multiproof for multiple points
fn verify_multi_kzg_proof(
    commitment_bytes: &KzgCommitment,
    zs_bytes: &[Bytes32],
    ys_bytes: &[Bytes32],
    proof_bytes: &KzgProof,
    s: &KzgSettings,
) -> Result<bool, Error> {
    let k = zs_bytes.len();
    if k == 0 || k != ys_bytes.len() {
        return Err(Error::BadArgs(
            "verify_multi_kzg_proof bad input".to_string(),
        ));
    }
    if k >= TRUSTED_SETUP_NUM_G2_POINTS as usize {
        return Err(Error::BadArgs("too many points for multiproof".to_string()));
    }

    let commitment = bytes_to_kzg_commitment(&commitment_bytes.0)?;
    let proof = bytes_to_kzg_proof(&proof_bytes.0)?;

    // Convert zs, ys to fr
    let mut zs: Vec<fr_t> = Vec::with_capacity(k);
    let mut ys: Vec<fr_t> = Vec::with_capacity(k);
    for i in 0..k {
        zs.push(bytes_to_bls_field(&zs_bytes[i])?);
        ys.push(bytes_to_bls_field(&ys_bytes[i])?);
    }

    // Compute I(_j)
    let (i_evals, _) = interpolant_evals_on_domain(&zs, &ys, s)?;

    // Compute [I()] in G1 (Lagrange form)
    let c_i = g1_lincomb_naive(&s.g1_values, &i_evals)?;

    // Compute [Z()] in G2 from coefficients
    let z_coeffs = poly_from_roots_coeffs(&zs)?; // degree k
    let z_g2 = g2_lincomb_naive(&s.g2_values[..z_coeffs.len()], &z_coeffs)?;

    // Check e(proof, [Z()]) == e(C - [I()], [1])
    let c_minus_i = g1_sub(&commitment, &c_i);
    Ok(pairings_verify(&proof, &z_g2, &c_minus_i, &G2_GENERATOR))
}

================
File: src/lib.rs
================
mod consts;
mod kzg;
mod test_formats;
mod trusted_setup;
mod utils;

pub use consts::{
    BYTES_PER_BLOB, BYTES_PER_COMMITMENT, BYTES_PER_FIELD_ELEMENT, BYTES_PER_G1, BYTES_PER_G2,
    BYTES_PER_PROOF, FIELD_ELEMENTS_PER_BLOB,
};
pub use kzg::{Blob, Bytes32, Bytes48, Error, Kzg, KzgCommitment, KzgProof};
pub use trusted_setup::TrustedSetup;

#[cfg(test)]
mod tests {
    use super::kzg::*;
    use super::*;
    use std::fs;
    use std::path::PathBuf;
    use test_formats::*;

    const TRUSTED_SETUP: &str = "trusted_setup.txt";
    const BLOB_TO_KZG_COMMITMENT_TESTS: &str = "tests/blob_to_kzg_commitment/*/*/*";
    const COMPUTE_KZG_PROOF_TESTS: &str = "tests/compute_kzg_proof/*/*/*";
    const COMPUTE_BLOB_KZG_PROOF_TESTS: &str = "tests/compute_blob_kzg_proof/*/*/*";
    const VERIFY_KZG_PROOF_TESTS: &str = "tests/verify_kzg_proof/*/*/*";
    const VERIFY_BLOB_KZG_PROOF_TESTS: &str = "tests/verify_blob_kzg_proof/*/*/*";
    const VERIFY_BLOB_KZG_PROOF_BATCH_TESTS: &str = "tests/verify_blob_kzg_proof_batch/*/*/*";

    fn bytes32_from_u64(n: u64) -> Bytes32 {
        let mut b = [0u8; 32];
        b[24..32].copy_from_slice(&n.to_be_bytes());
        Bytes32::from_bytes(&b).unwrap()
    }

    fn make_nontrivial_blob() -> Blob {
        // Create a deterministic nontrivial evaluation-form polynomial by
        // setting the j-th evaluation to f(j) = j^3 + 7*j + 11 (mod Fr).
        let mut blob_bytes = vec![0u8; BYTES_PER_BLOB];
        for j in 0..FIELD_ELEMENTS_PER_BLOB {
            let jj = j as u64;
            let val = jj
                .saturating_mul(jj)
                .saturating_mul(jj)
                .saturating_add(7 * jj)
                .saturating_add(11);
            let fe = bytes32_from_u64(val);
            let start = j * BYTES_PER_FIELD_ELEMENT;
            blob_bytes[start..start + BYTES_PER_FIELD_ELEMENT].copy_from_slice(&fe.bytes);
        }
        Blob::from_bytes(&blob_bytes).unwrap()
    }

    #[test]
    fn test_multi_kzg_proof_sizes_and_verify() {
        let s = Kzg::load_trusted_setup_file(TRUSTED_SETUP).unwrap();
        let blob = make_nontrivial_blob();
        let commitment = Kzg::blob_to_kzg_commitment(&blob, &s).unwrap();

        let sizes = [1usize, 2, 5, 10];
        let z_values: [u64; 10] = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31];
        for &k in &sizes {
            let zs: Vec<Bytes32> = z_values[..k].iter().map(|&v| bytes32_from_u64(v)).collect();

            // compute multiproof and get ys
            let (proof, ys) = Kzg::compute_multi_kzg_proof(&blob, &zs, &s).unwrap();

            // proof size must be constant 48 bytes regardless of k
            assert_eq!(proof.0.bytes.len(), BYTES_PER_PROOF);

            // verify should pass
            assert!(Kzg::verify_multi_kzg_proof(&commitment, &zs, &ys, &proof, &s).unwrap());

            // tamper one y and ensure verification fails
            let mut ys_bad = ys.clone();
            // flip last byte of first y to change value deterministically
            ys_bad[0].bytes[31] ^= 1;
            assert!(!Kzg::verify_multi_kzg_proof(&commitment, &zs, &ys_bad, &proof, &s).unwrap());
        }
    }

    #[test]
    fn test_blob_to_kzg_commitment() {
        let kzg_settings = Kzg::load_trusted_setup_file(TRUSTED_SETUP).unwrap();
        let test_files: Vec<PathBuf> = glob::glob(BLOB_TO_KZG_COMMITMENT_TESTS)
            .unwrap()
            .map(Result::unwrap)
            .collect();
        assert!(!test_files.is_empty());

        for test_file in test_files {
            let yaml_data = fs::read_to_string(test_file).unwrap();
            let test: blob_to_kzg_commitment_test::Test = serde_yaml::from_str(&yaml_data).unwrap();
            let Ok(blob) = test.input.get_blob() else {
                assert!(test.get_output().is_none());
                continue;
            };

            match Kzg::blob_to_kzg_commitment(&blob, &kzg_settings) {
                Ok(res) => assert_eq!(res.0.bytes, test.get_output().unwrap().bytes),
                _ => assert!(test.get_output().is_none()),
            }
        }
    }

    #[test]
    fn test_compute_kzg_proof() {
        let kzg_settings = Kzg::load_trusted_setup_file(TRUSTED_SETUP).unwrap();
        let test_files: Vec<PathBuf> = glob::glob(COMPUTE_KZG_PROOF_TESTS)
            .unwrap()
            .map(Result::unwrap)
            .collect();
        assert!(!test_files.is_empty());

        for test_file in test_files {
            let yaml_data = fs::read_to_string(test_file).unwrap();
            let test: compute_kzg_proof::Test = serde_yaml::from_str(&yaml_data).unwrap();
            let (Ok(blob), Ok(z)) = (test.input.get_blob(), test.input.get_z()) else {
                assert!(test.get_output().is_none());
                continue;
            };

            match Kzg::compute_kzg_proof(&blob, &z, &kzg_settings) {
                Ok((proof, y)) => {
                    assert_eq!(proof.0.bytes, test.get_output().unwrap().0.bytes);
                    assert_eq!(y.bytes, test.get_output().unwrap().1.bytes);
                }
                _ => assert!(test.get_output().is_none()),
            }
        }
    }

    #[test]
    fn test_compute_blob_kzg_proof() {
        let kzg_settings = Kzg::load_trusted_setup_file(TRUSTED_SETUP).unwrap();
        let test_files: Vec<PathBuf> = glob::glob(COMPUTE_BLOB_KZG_PROOF_TESTS)
            .unwrap()
            .map(Result::unwrap)
            .collect();
        assert!(!test_files.is_empty());

        for test_file in test_files {
            let yaml_data = fs::read_to_string(test_file).unwrap();
            let test: compute_blob_kzg_proof::Test = serde_yaml::from_str(&yaml_data).unwrap();
            let (Ok(blob), Ok(commitment)) = (test.input.get_blob(), test.input.get_commitment())
            else {
                assert!(test.get_output().is_none());
                continue;
            };

            match Kzg::compute_blob_kzg_proof(&blob, &KzgCommitment(commitment), &kzg_settings) {
                Ok(res) => assert_eq!(res.0.bytes, test.get_output().unwrap().bytes),

                _ => assert!(test.get_output().is_none()),
            }
        }
    }

    #[test]
    fn test_verify_kzg_proof() {
        let kzg_settings = Kzg::load_trusted_setup_file(TRUSTED_SETUP).unwrap();
        let test_files: Vec<PathBuf> = glob::glob(VERIFY_KZG_PROOF_TESTS)
            .unwrap()
            .map(Result::unwrap)
            .collect();
        assert!(!test_files.is_empty());

        for test_file in test_files {
            let yaml_data = fs::read_to_string(test_file).unwrap();
            let test: test_formats::verify_kzg_proof::Test =
                serde_yaml::from_str(&yaml_data).unwrap();
            let (Ok(commitment), Ok(z), Ok(y), Ok(proof)) = (
                test.input.get_commitment(),
                test.input.get_z(),
                test.input.get_y(),
                test.input.get_proof(),
            ) else {
                assert!(test.get_output().is_none());
                continue;
            };
            match Kzg::verify_kzg_proof(
                &KzgCommitment(commitment),
                &z,
                &y,
                &KzgProof(proof),
                &kzg_settings,
            ) {
                Ok(res) => {
                    assert_eq!(res, test.get_output().unwrap());
                }
                _ => assert!(test.get_output().is_none()),
            }
        }
    }

    #[test]
    fn test_verify_blob_kzg_proof() {
        let kzg_settings = Kzg::load_trusted_setup_file(TRUSTED_SETUP).unwrap();
        let test_files: Vec<PathBuf> = glob::glob(VERIFY_BLOB_KZG_PROOF_TESTS)
            .unwrap()
            .map(Result::unwrap)
            .collect();
        assert!(!test_files.is_empty());

        for test_file in test_files {
            let yaml_data = fs::read_to_string(test_file).unwrap();
            let test: verify_blob_kzg_proof::Test = serde_yaml::from_str(&yaml_data).unwrap();
            let (Ok(blob), Ok(commitment), Ok(proof)) = (
                test.input.get_blob(),
                test.input.get_commitment(),
                test.input.get_proof(),
            ) else {
                assert!(test.get_output().is_none());
                continue;
            };

            match Kzg::verify_blob_kzg_proof(
                &blob,
                &KzgCommitment(commitment),
                &KzgProof(proof),
                &kzg_settings,
            ) {
                Ok(res) => assert_eq!(res, test.get_output().unwrap()),
                _ => assert!(test.get_output().is_none()),
            }
        }
    }

    #[test]
    fn test_verify_blob_kzg_proof_batch() {
        let kzg_settings = Kzg::load_trusted_setup_file(TRUSTED_SETUP).unwrap();
        let test_files: Vec<PathBuf> = glob::glob(VERIFY_BLOB_KZG_PROOF_BATCH_TESTS)
            .unwrap()
            .map(Result::unwrap)
            .collect();
        assert!(!test_files.is_empty());

        for test_file in test_files {
            let yaml_data = fs::read_to_string(&test_file).unwrap();
            let test: verify_blob_kzg_proof_batch::Test = serde_yaml::from_str(&yaml_data).unwrap();
            let (Ok(blobs), Ok(commitments), Ok(proofs)) = (
                test.input.get_blobs(),
                test.input.get_commitments(),
                test.input.get_proofs(),
            ) else {
                assert!(test.get_output().is_none());
                continue;
            };
            match Kzg::verify_blob_kzg_proof_batch(&blobs, &commitments, &proofs, &kzg_settings) {
                Ok(res) => assert_eq!(res, test.get_output().unwrap()),

                _ => assert!(test.get_output().is_none()),
            }
        }
    }
}

================
File: src/trusted_setup.rs
================
use crate::{BYTES_PER_G1, BYTES_PER_G2, FIELD_ELEMENTS_PER_BLOB};
use serde::de::{self, Deserializer, Visitor};
use serde::{Deserialize, Serialize};

/// Wrapper over a BLS G1 point's byte representation.
#[derive(Debug, Clone, PartialEq)]
struct G1Point([u8; BYTES_PER_G1]);

/// Wrapper over a BLS G2 point's byte representation.
#[derive(Debug, Clone, PartialEq)]
struct G2Point([u8; BYTES_PER_G2]);

/// Contains the trusted setup parameters that are required to instantiate a
/// `c_kzg::KzgSettings` object.
///
/// The serialize/deserialize implementations are written according to
/// the format specified in the the ethereum consensus specs trusted setup files.
///
/// See https://github.com/ethereum/consensus-specs/blob/dev/presets/mainnet/trusted_setups/testing_trusted_setups.json
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TrustedSetup {
    #[serde(rename = "setup_G1_lagrange")]
    #[serde(deserialize_with = "deserialize_g1_points::<__D>")]
    g1_points: Vec<G1Point>,
    #[serde(rename = "setup_G2")]
    g2_points: Vec<G2Point>,
}

impl TrustedSetup {
    pub fn g1_points(&self) -> Vec<[u8; BYTES_PER_G1]> {
        self.g1_points.iter().map(|p| p.0).collect()
    }

    pub fn g2_points(&self) -> Vec<[u8; BYTES_PER_G2]> {
        self.g2_points.iter().map(|p| p.0).collect()
    }

    pub fn g1_len(&self) -> usize {
        self.g1_points.len()
    }
    pub fn g2_len(&self) -> usize {
        self.g2_points.len()
    }
}

impl Serialize for G1Point {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let point = hex::encode(self.0);
        serializer.serialize_str(&point)
    }
}

impl Serialize for G2Point {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let point = hex::encode(self.0);
        serializer.serialize_str(&point)
    }
}

impl<'de> Deserialize<'de> for G1Point {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct G1PointVisitor;

        impl<'de> Visitor<'de> for G1PointVisitor {
            type Value = G1Point;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("A 48 byte hex encoded string")
            }

            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                let point = hex::decode(strip_prefix(v))
                    .map_err(|e| de::Error::custom(format!("Failed to decode G1 point: {}", e)))?;
                if point.len() != BYTES_PER_G1 {
                    return Err(de::Error::custom(format!(
                        "G1 point has invalid length. Expected {} got {}",
                        BYTES_PER_G1,
                        point.len()
                    )));
                }
                let mut res = [0; BYTES_PER_G1];
                res.copy_from_slice(&point);
                Ok(G1Point(res))
            }
        }

        deserializer.deserialize_str(G1PointVisitor)
    }
}

impl<'de> Deserialize<'de> for G2Point {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct G2PointVisitor;

        impl<'de> Visitor<'de> for G2PointVisitor {
            type Value = G2Point;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("A 96 byte hex encoded string")
            }

            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                let point = hex::decode(strip_prefix(v))
                    .map_err(|e| de::Error::custom(format!("Failed to decode G2 point: {}", e)))?;
                if point.len() != BYTES_PER_G2 {
                    return Err(de::Error::custom(format!(
                        "G2 point has invalid length. Expected {} got {}",
                        BYTES_PER_G2,
                        point.len()
                    )));
                }
                let mut res = [0; BYTES_PER_G2];
                res.copy_from_slice(&point);
                Ok(G2Point(res))
            }
        }

        deserializer.deserialize_str(G2PointVisitor)
    }
}

fn deserialize_g1_points<'de, D>(deserializer: D) -> Result<Vec<G1Point>, D::Error>
where
    D: Deserializer<'de>,
{
    let mut decoded: Vec<G1Point> = serde::de::Deserialize::deserialize(deserializer)?;
    // FIELD_ELEMENTS_PER_BLOB is generic const which decides if the kzg operations
    // are for minimal or mainnet spec requirements.
    // Minimal and mainnet trusted setup parameters differ only by the
    // number of G1 points they contain.
    //
    // Hence, we truncate the number of G1 points after deserialisation
    // to ensure that we have the right number of g1 points in the
    // trusted setup.
    decoded.truncate(FIELD_ELEMENTS_PER_BLOB);
    Ok(decoded)
}

fn strip_prefix(s: &str) -> &str {
    if let Some(stripped) = s.strip_prefix("0x") {
        stripped
    } else {
        s
    }
}

================
File: src/utils.rs
================
use crate::consts::*;
use crate::kzg::{Bytes32, Bytes48, Error};
use blst::*;
use blst::{blst_fr as fr_t, blst_p1 as g1_t, blst_p2 as g2_t};
use BLST_ERROR::BLST_SUCCESS;

/* Helper Functions */

/// Test whether the operand is one in the finite field.
pub(crate) fn fr_is_one(p: &fr_t) -> bool {
    let mut a = [0u64; 4];
    unsafe {
        blst_uint64_from_fr(a.as_mut_ptr(), p);
    }
    a[0] == 1 && a[1] == 0 && a[2] == 0 && a[3] == 0
}

/// Test whether the operand is zero in the finite field.
///
/// NOTE: deviates from c_kzg_4844.c to use rust's `PartialEq` impl
/// since `FR_ZERO` is defined as [0, 0, 0, 0]
pub(crate) fn fr_is_zero(p: &fr_t) -> bool {
    *p == FR_ZERO
}

/// Test whether two field elements are equal.
pub(crate) fn fr_equal(aa: &fr_t, bb: &fr_t) -> bool {
    let mut a = [0u64; 4];
    let mut b = [0u64; 4];

    unsafe {
        blst_uint64_from_fr(a.as_mut_ptr(), aa);
        blst_uint64_from_fr(b.as_mut_ptr(), bb);
    }

    a == b
}

/// Divide a field element by another.
///
/// NOTE: The behaviour for `b == 0` is unspecified.
pub(crate) fn fr_div(a: fr_t, b: fr_t) -> fr_t {
    let mut tmp = blst_fr::default();
    let mut res = blst_fr::default();
    unsafe {
        blst_fr_eucl_inverse(&mut tmp, &b);
        blst_fr_mul(&mut res, &a, &tmp);
        res
    }
}

/// Exponentiation of a field element `a` to `n`.
///
/// Uses square and multiply for `log(n)` performance.
///
/// NOTE: A 64-bit exponent is sufficient for our needs here.
pub(crate) fn fr_pow(a: fr_t, mut n: u64) -> fr_t {
    let mut tmp = a;
    let mut res = FR_ONE;

    unsafe {
        loop {
            if n & 1 != 0 {
                blst_fr_mul(&mut res, &res, &tmp);
            }

            n >>= 1;
            if n == 0 {
                break;
            }
            blst_fr_sqr(&mut tmp, &tmp);
        }
        res
    }
}

/// Create a field element from a single 64-bit unsigned integer.
///
/// This can only generate a tiny fraction of possible field elements,
/// and is mostly useful for testing.
pub(crate) fn fr_from_uint64(n: u64) -> fr_t {
    let vals = [n, 0, 0, 0];
    let mut res = blst_fr::default();
    unsafe {
        blst_fr_from_uint64(&mut res, vals.as_ptr());
        res
    }
}

/// Montgomery batch inversion in finite field.
///
/// This function only supports non zero lengths of `a`.
/// Note: Returns `Error::BadArgs` if zero is found in the input slice.
pub(crate) fn fr_batch_inv(a: &[fr_t]) -> Result<Vec<fr_t>, Error> {
    if a.is_empty() {
        return Err(Error::BadArgs("fr_batch_inv input is empty".to_string()));
    }
    let mut res: Vec<fr_t> = Vec::with_capacity(a.len());
    let mut accumulator = FR_ONE;
    for elem in a {
        res.push(accumulator);
        unsafe {
            blst_fr_mul(&mut accumulator, &accumulator, elem);
        }
    }
    // Bail on zero input
    if fr_is_zero(&accumulator) {
        return Err(Error::BadArgs("fr_batch_inv zero input".to_string()));
    }

    unsafe {
        blst_fr_eucl_inverse(&mut accumulator, &accumulator);
    }

    for i in (0..a.len()).rev() {
        unsafe {
            blst_fr_mul(&mut res[i], &res[i], &accumulator);
            blst_fr_mul(&mut accumulator, &accumulator, &a[i]);
        }
    }

    Ok(res)
}

/// Multiply a G1 group element by a field element.
pub(crate) fn g1_mul(a: &g1_t, b: &fr_t) -> g1_t {
    let mut s = blst_scalar::default();
    let mut res = g1_t::default();
    unsafe {
        blst_scalar_from_fr(&mut s, b);
        // The last argument is the number of bits in the scalar
        blst_p1_mult(
            &mut res,
            a,
            s.b.as_ptr(),
            8 * std::mem::size_of::<blst_scalar>(),
        );
        res
    }
}

/// Multiply a G2 group element by a field element.
pub(crate) fn g2_mul(a: &g2_t, b: &fr_t) -> g2_t {
    let mut s = blst_scalar::default();
    let mut res = g2_t::default();
    unsafe {
        blst_scalar_from_fr(&mut s, b);
        // The last argument is the number of bits in the scalar
        blst_p2_mult(
            &mut res,
            a,
            s.b.as_ptr(),
            8 * std::mem::size_of::<blst_scalar>(),
        );
        res
    }
}

/// Subtraction of G1 group elements.
///
/// Returns `a - b`
pub(crate) fn g1_sub(a: &g1_t, b: &g1_t) -> g1_t {
    let mut b_neg = *b;
    let mut res = g1_t::default();
    unsafe {
        blst_p1_cneg(&mut b_neg, true);
        blst_p1_add_or_double(&mut res, a, &b_neg);
    }
    res
}

/// Subtraction of G2 group elements.
///
/// Returns `a - b`
pub(crate) fn g2_sub(a: &g2_t, b: &g2_t) -> g2_t {
    let mut b_neg = *b;
    let mut res = g2_t::default();
    unsafe {
        blst_p2_cneg(&mut b_neg, true);
        blst_p2_add_or_double(&mut res, a, &b_neg);
    }
    res
}

/// Perform pairings and test whether the outcomes are equal in `G_T`.
///
/// Tests whether `e(a1, a2) == e(b1, b2)`.
///
pub(crate) fn pairings_verify(a1: &g1_t, a2: &g2_t, b1: &g1_t, b2: &g2_t) -> bool {
    let (mut loop0, mut loop1, mut gt_point) = Default::default();
    let (mut aa1, mut bb1) = Default::default();
    let (mut aa2, mut bb2) = Default::default();

    /*
     * As an optimisation, we want to invert one of the pairings,
     * so we negate one of the points.
     */
    let mut a1_neg = *a1;
    unsafe {
        blst_p1_cneg(&mut a1_neg, true);
        blst_p1_to_affine(&mut aa1, &a1_neg);
        blst_p1_to_affine(&mut bb1, b1);
        blst_p2_to_affine(&mut aa2, a2);
        blst_p2_to_affine(&mut bb2, b2);

        blst_miller_loop(&mut loop0, &aa2, &aa1);
        blst_miller_loop(&mut loop1, &bb2, &bb1);

        blst_fp12_mul(&mut gt_point, &loop0, &loop1);
        blst_final_exp(&mut gt_point, &gt_point);

        blst_fp12_is_one(&gt_point)
    }
}

///////////////////////////////////////////////////////////////////////////////
// Bytes Conversion Helper Functions
///////////////////////////////////////////////////////////////////////////////

/// Serialize a G1 group element into bytes.
pub(crate) fn bytes_from_g1(g1_point: &g1_t) -> Bytes48 {
    let mut bytes = Bytes48::default();
    unsafe {
        blst_p1_compress(bytes.bytes.as_mut_ptr(), g1_point);
    }
    bytes
}

/// Serialize a BLS field element into bytes.
pub fn bytes_from_bls_field(field_element: &fr_t) -> Bytes32 {
    let mut s = blst_scalar::default();
    let mut res = Bytes32::default();
    unsafe {
        blst_scalar_from_fr(&mut s, field_element);
        blst_bendian_from_scalar(res.bytes.as_mut_ptr(), &s);
    }
    res
}

/// Serialize a 64-bit unsigned integer into big endian bytes.
pub(crate) fn bytes_from_uint64(n: u64) -> [u8; 8] {
    n.to_be_bytes()
}

///////////////////////////////////////////////////////////////////////////////
// BLS12-381 Helper Functions
///////////////////////////////////////////////////////////////////////////////

/// Map bytes to a BLS field element.
pub(crate) fn hash_to_bls_field(b: &Bytes32) -> fr_t {
    let mut tmp = blst_scalar::default();
    let mut res = fr_t::default();
    unsafe {
        blst_scalar_from_bendian(&mut tmp, b.bytes.as_ptr());
        blst_fr_from_scalar(&mut res, &tmp);
    }
    res
}

/// Convert untrusted bytes to a trusted and validated BLS scalar field
/// element.
pub(crate) fn bytes_to_bls_field(b: &Bytes32) -> Result<fr_t, Error> {
    let mut tmp = blst_scalar::default();
    let mut res = fr_t::default();
    unsafe {
        blst_scalar_from_bendian(&mut tmp, b.bytes.as_ptr());
        if !blst_scalar_fr_check(&tmp) {
            return Err(Error::BadArgs(
                "bytes_to_bls_field Invalid Bytes32".to_string(),
            ));
        }
        blst_fr_from_scalar(&mut res, &tmp);
        Ok(res)
    }
}

/// Perform BLS validation required by the types `KZGProof` and `KZGCommitment`.
///
/// Note: This function deviates from the spec because it returns (via an
/// output argument) the g1 point. This way is more efficient (faster)
/// but the function name is a bit misleading.
pub(crate) fn validate_kzg_g1(b: &Bytes48) -> Result<g1_t, Error> {
    let mut p1_affine = blst_p1_affine::default();
    let mut res = g1_t::default();

    /* Convert the bytes to a p1 point */
    /* The uncompress routine checks that the point is on the curve */

    unsafe {
        let ret = blst_p1_uncompress(&mut p1_affine, b.bytes.as_ptr());
        if ret != BLST_SUCCESS {
            return Err(Error::BadArgs(format!(
                "validate_kzg_g1 blst_p1_uncompress failed err {:?}",
                res
            )));
        }
        blst_p1_from_affine(&mut res, &p1_affine);
        /* The point at infinity is accepted! */
        if blst_p1_is_inf(&res) {
            return Ok(res);
        }
        /* The point must be on the right subgroup */
        if !blst_p1_in_g1(&res) {
            return Err(Error::BadArgs(
                "validate_kzg_g1 not in right subgroup".to_string(),
            ));
        }
    }
    Ok(res)
}

/// Convert untrusted bytes into a trusted and validated KZGCommitment.
pub fn bytes_to_kzg_commitment(b: &Bytes48) -> Result<g1_t, Error> {
    validate_kzg_g1(b)
}

/// Convert untrusted bytes into a trusted and validated KZGProof.
pub fn bytes_to_kzg_proof(b: &Bytes48) -> Result<g1_t, Error> {
    validate_kzg_g1(b)
}

/// Calculate a linear combination of G1 group elements.
///
/// Calculates `[coeffs_0]p_0 + [coeffs_1]p_1 + ... + [coeffs_n]p_n`
/// where `n` is `len - 1`.
///
/// This function computes the result naively without using Pippenger's
/// algorithm.
pub(crate) fn g1_lincomb_naive(p: &[g1_t], coeffs: &[fr_t]) -> Result<g1_t, Error> {
    if p.len() != coeffs.len() {
        return Err(Error::InternalError);
    }
    let len = p.len();

    let mut tmp;
    let mut res = G1_IDENTITY;
    for i in 0..len {
        tmp = g1_mul(&p[i], &coeffs[i]);
        unsafe { blst_p1_add_or_double(&mut res, &res, &tmp) }
    }
    Ok(res)
}

/// Calculate a linear combination of G2 group elements.
///
/// Calculates `[coeffs_0]p_0 + [coeffs_1]p_1 + ... + [coeffs_n]p_n`
/// where `n` is `len - 1`.
pub(crate) fn g2_lincomb_naive(p: &[g2_t], coeffs: &[fr_t]) -> Result<g2_t, Error> {
    if p.len() != coeffs.len() {
        return Err(Error::InternalError);
    }
    let len = p.len();

    let mut tmp;
    let mut res = g2_t::default();
    for i in 0..len {
        tmp = g2_mul(&p[i], &coeffs[i]);
        unsafe { blst_p2_add_or_double(&mut res, &res, &tmp) }
    }
    Ok(res)
}

///  Calculate a linear combination of G1 group elements.
///
///  Calculates `[coeffs_0]p_0 + [coeffs_1]p_1 + ... + [coeffs_n]p_n`
///  where `n` is `len - 1`.
///
///  NOTE: This function **MUST NOT** be called with the point at infinity in `p`.
///
///  While this function is significantly faster than
///  `g1_lincomb_naive()`, we refrain from using it in security-critical places
///  (like verification) because the blst Pippenger code has not been
///  audited. In those critical places, we prefer using `g1_lincomb_naive()` which
///  is much simpler.
///
///  For the benefit of future generations (since Blst has no documentation to
///  speak of), there are two ways to pass the arrays of scalars and points
///  into blst_p1s_mult_pippenger().
///
///  1. Pass `points` as an array of pointers to the points, and pass
///     `scalars` as an array of pointers to the scalars, each of length p.len().
///  2. Pass an array where the first element is a pointer to the contiguous
///     array of points and the second is null, and similarly for scalars.
///
///  We do the second of these to save memory here.
pub(crate) fn g1_lincomb_fast(p: &[g1_t], coeffs: &[fr_t]) -> Result<g1_t, Error> {
    let len = p.len();
    if len < 8 {
        return g1_lincomb_naive(p, coeffs);
    }
    let scratch_size: usize;
    let mut res = g1_t::default();
    unsafe {
        scratch_size = blst_p1s_mult_pippenger_scratch_sizeof(len);
    }
    // Note: In the C code, `scratch` is a a void pointer. We use a u64 array because
    // the ffi function `blst_p1s_mult_pippenger` implementation below accepts a pointer of form
    // *mut u64.
    let mut scratch: Vec<_> = (0..scratch_size).map(|_| 0u64).collect();
    let mut p_affine: Vec<_> = (0..len).map(|_| blst_p1_affine::default()).collect();
    let mut scalars: Vec<_> = (0..len).map(|_| blst_scalar::default()).collect();

    /* Transform the points to affine representation */
    unsafe {
        let p_arg: [_; 2] = [p.as_ptr(), std::ptr::null()];
        blst_p1s_to_affine(p_affine.as_mut_ptr(), p_arg.as_ptr(), len);

        /* Transform the field elements to 256-bit scalars */
        for i in 0..len {
            blst_scalar_from_fr(&mut scalars[i], &coeffs[i])
        }

        /* Call the Pippenger implementation */
        // Note: the corresponding C code is
        // const byte *scalars_arg[2] = {(byte *)scalars, NULL};
        let scalars_arg: [_; 2] = [scalars[0].b.as_ptr(), std::ptr::null()];
        let points_arg: [_; 2] = [p_affine.as_ptr(), std::ptr::null()];
        blst_p1s_mult_pippenger(
            &mut res,
            points_arg.as_ptr(),
            len,
            scalars_arg.as_ptr(),
            255,
            scratch.as_mut_ptr(),
        );
    }

    Ok(res)
}

/// Compute and return [ x^0, x^1, ..., x^{n-1} ].
pub(crate) fn compute_powers(x: &fr_t, n: usize) -> Vec<fr_t> {
    let mut current_power = FR_ONE;
    let mut res = Vec::with_capacity(n);
    for _ in 0..n {
        res.push(current_power);
        unsafe {
            blst_fr_mul(&mut current_power, &current_power, x);
        }
    }
    res
}

/// Compute random linear combination challenge scalars for batch verification.
pub(crate) fn compute_r_powers(
    commitments_g1: &[g1_t],
    zs_fr: &[fr_t],
    ys_fr: &[fr_t],
    proofs_g1: &[g1_t],
) -> Result<Vec<fr_t>, Error> {
    if commitments_g1.len() != zs_fr.len()
        && commitments_g1.len() != ys_fr.len()
        && commitments_g1.len() != proofs_g1.len()
    {
        return Err(Error::InternalError);
    }
    let n = commitments_g1.len();
    let input_size = DOMAIN_STR_LENGTH
        + std::mem::size_of::<u64>()
        + std::mem::size_of::<u64>()
        + (n * (BYTES_PER_COMMITMENT + 2 * BYTES_PER_FIELD_ELEMENT + BYTES_PER_PROOF));

    let mut bytes: Vec<u8> = Vec::with_capacity(input_size);
    /* Copy domain separator */
    bytes.extend_from_slice(RANDOM_CHALLENGE_KZG_BATCH_DOMAIN.as_bytes());

    /* Copy degree of the polynomial */
    bytes.extend_from_slice(&FIELD_ELEMENTS_PER_BLOB.to_be_bytes());

    /* Copy number of commitments */
    bytes.extend_from_slice(&n.to_be_bytes());

    for i in 0..n {
        /* Copy commitment */
        bytes.extend_from_slice(&bytes_from_g1(&commitments_g1[i]).bytes);
        /* Copy z */
        bytes.extend_from_slice(&bytes_from_bls_field(&zs_fr[i]).bytes);
        /* Copy y */
        bytes.extend_from_slice(&bytes_from_bls_field(&ys_fr[i]).bytes);
        /* Copy proof */
        bytes.extend_from_slice(&bytes_from_g1(&proofs_g1[i]).bytes);
    }
    if bytes.len() != input_size {
        return Err(Error::InternalError);
    }
    /* Now let's create the challenge! */
    let mut r_bytes = Bytes32::default();
    unsafe {
        blst_sha256(r_bytes.bytes.as_mut_ptr(), bytes.as_ptr(), input_size);
    }
    let r = hash_to_bls_field(&r_bytes);
    Ok(compute_powers(&r, n))
}

================
File: README.md
================
# KZG Rust

Rust port of https://github.com/ethereum/c-kzg-4844 . Uses the blst rust bindings for all BLS functionality.

Tries to be almost a line to line port of the C code in `c_kzg_4844.c` while rearranging some consts and utils into
their own rust modules. Runs same test vectors from the original repository.

The crate exports 2 modules: `kzg_mainnet` and `kzg_minimal` which correspond to the mainnet and minimal spec variants
in the [ethereum consensus specs](https://github.com/ethereum/consensus-specs/tree/dev/presets)

Each module contains the following:

Following constants:
- `FIELD_ELEMENTS_PER_BLOB`
- `BYTES_PER_BLOB`

A `Kzg` struct with the associated methods:

- `load_trusted_setup`
- `load_trusted_setup_file`
- `blob_to_kzg_commitment`
- `compute_kzg_proof`
- `compute_blob_kzg_proof`
- `verify_kzg_proof`
- `verify_blob_kzg_proof`
- `verify_blob_kzg_proof_batch`

The following structs with specified values of the `FIELD_ELEMENTS_PER_BLOB` constant which refers to either mainnet or minimal spec parameters:
- `Blob`
- `KzgSettings`
- `TrustedSetup`

The `TrustedSetup` struct is provided as an additional helper struct in this library to parse trusted setups in the json format provided in the 
[ethereum consensus specs](https://github.com/ethereum/consensus-specs/blob/dev/presets/mainnet/trusted_setups/testing_trusted_setups.json)



## Benchmarks
```bash
cargo bench
```


================================================================
End of Codebase
================================================================
